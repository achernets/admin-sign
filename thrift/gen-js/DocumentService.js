//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//
if (typeof Int64 === 'undefined' && typeof require === 'function') {
  const Int64 = require('node-int64');
}


//HELPER FUNCTIONS AND STRUCTURES

DocumentService_calculatePermissions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_calculatePermissions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocPermissions(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocPermissions();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_calculatePermissions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.accessPolicy = null;
    this.addedResponsibles = null;
    this.removedResponsibles = null;
    this.addedSecurityClassificationIds = null;
    this.removedSecurityClassificationIds = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.addedResponsibles !== undefined && args.addedResponsibles !== null) {
        this.addedResponsibles = Thrift.copyList(args.addedResponsibles, [UserOrGroup]);
      }
      if (args.removedResponsibles !== undefined && args.removedResponsibles !== null) {
        this.removedResponsibles = Thrift.copyList(args.removedResponsibles, [UserOrGroup]);
      }
      if (args.addedSecurityClassificationIds !== undefined && args.addedSecurityClassificationIds !== null) {
        this.addedSecurityClassificationIds = Thrift.copyList(args.addedSecurityClassificationIds, [null]);
      }
      if (args.removedSecurityClassificationIds !== undefined && args.removedSecurityClassificationIds !== null) {
        this.removedSecurityClassificationIds = Thrift.copyList(args.removedSecurityClassificationIds, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.addedResponsibles = [];
          const _rtmp3261 = input.readListBegin();
          const _size260 = _rtmp3261.size || 0;
          for (let _i262 = 0; _i262 < _size260; ++_i262) {
            let elem263 = null;
            elem263 = new UserOrGroup();
            elem263.read(input);
            this.addedResponsibles.push(elem263);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.removedResponsibles = [];
          const _rtmp3265 = input.readListBegin();
          const _size264 = _rtmp3265.size || 0;
          for (let _i266 = 0; _i266 < _size264; ++_i266) {
            let elem267 = null;
            elem267 = new UserOrGroup();
            elem267.read(input);
            this.removedResponsibles.push(elem267);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.addedSecurityClassificationIds = [];
          const _rtmp3269 = input.readListBegin();
          const _size268 = _rtmp3269.size || 0;
          for (let _i270 = 0; _i270 < _size268; ++_i270) {
            let elem271 = null;
            elem271 = input.readString().value;
            this.addedSecurityClassificationIds.push(elem271);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.removedSecurityClassificationIds = [];
          const _rtmp3273 = input.readListBegin();
          const _size272 = _rtmp3273.size || 0;
          for (let _i274 = 0; _i274 < _size272; ++_i274) {
            let elem275 = null;
            elem275 = input.readString().value;
            this.removedSecurityClassificationIds.push(elem275);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.addedResponsibles !== null && this.addedResponsibles !== undefined) {
      output.writeFieldBegin('addedResponsibles', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.addedResponsibles.length);
      for (let iter276 in this.addedResponsibles) {
        if (this.addedResponsibles.hasOwnProperty(iter276)) {
          iter276 = this.addedResponsibles[iter276];
          iter276.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedResponsibles !== null && this.removedResponsibles !== undefined) {
      output.writeFieldBegin('removedResponsibles', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.removedResponsibles.length);
      for (let iter277 in this.removedResponsibles) {
        if (this.removedResponsibles.hasOwnProperty(iter277)) {
          iter277 = this.removedResponsibles[iter277];
          iter277.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.addedSecurityClassificationIds !== null && this.addedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('addedSecurityClassificationIds', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRING, this.addedSecurityClassificationIds.length);
      for (let iter278 in this.addedSecurityClassificationIds) {
        if (this.addedSecurityClassificationIds.hasOwnProperty(iter278)) {
          iter278 = this.addedSecurityClassificationIds[iter278];
          output.writeString(iter278);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.removedSecurityClassificationIds !== null && this.removedSecurityClassificationIds !== undefined) {
      output.writeFieldBegin('removedSecurityClassificationIds', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRING, this.removedSecurityClassificationIds.length);
      for (let iter279 in this.removedSecurityClassificationIds) {
        if (this.removedSecurityClassificationIds.hasOwnProperty(iter279)) {
          iter279 = this.removedSecurityClassificationIds[iter279];
          output.writeString(iter279);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_args = class {
  constructor(args) {
    this.token = null;
    this.document = null;
    this.users = null;
    this.holderLinks = null;
    this.securityClassificationsId = null;
    this.attachments = null;
    this.docRelations = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.document !== undefined && args.document !== null) {
        this.document = new Document(args.document);
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.securityClassificationsId !== undefined && args.securityClassificationsId !== null) {
        this.securityClassificationsId = Thrift.copyList(args.securityClassificationsId, [null]);
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.docRelations !== undefined && args.docRelations !== null) {
        this.docRelations = Thrift.copyList(args.docRelations, [DocumentRelation]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.document = new Document();
          this.document.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3281 = input.readListBegin();
          const _size280 = _rtmp3281.size || 0;
          for (let _i282 = 0; _i282 < _size280; ++_i282) {
            let elem283 = null;
            elem283 = new UserOrGroup();
            elem283.read(input);
            this.users.push(elem283);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3285 = input.readListBegin();
          const _size284 = _rtmp3285.size || 0;
          for (let _i286 = 0; _i286 < _size284; ++_i286) {
            let elem287 = null;
            elem287 = new ContentHolderLink();
            elem287.read(input);
            this.holderLinks.push(elem287);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.SET) {
          this.securityClassificationsId = [];
          const _rtmp3289 = input.readSetBegin();
          const _size288 = _rtmp3289.size || 0;
          for (let _i290 = 0; _i290 < _size288; ++_i290) {
            let elem291 = null;
            elem291 = input.readString().value;
            this.securityClassificationsId.push(elem291);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3293 = input.readListBegin();
          const _size292 = _rtmp3293.size || 0;
          for (let _i294 = 0; _i294 < _size292; ++_i294) {
            let elem295 = null;
            elem295 = new AttCreateInfo();
            elem295.read(input);
            this.attachments.push(elem295);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.docRelations = [];
          const _rtmp3297 = input.readListBegin();
          const _size296 = _rtmp3297.size || 0;
          for (let _i298 = 0; _i298 < _size296; ++_i298) {
            let elem299 = null;
            elem299 = new DocumentRelation();
            elem299.read(input);
            this.docRelations.push(elem299);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.document !== null && this.document !== undefined) {
      output.writeFieldBegin('document', Thrift.Type.STRUCT, 2);
      this.document.write(output);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter300 in this.users) {
        if (this.users.hasOwnProperty(iter300)) {
          iter300 = this.users[iter300];
          iter300.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter301 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter301)) {
          iter301 = this.holderLinks[iter301];
          iter301.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.securityClassificationsId !== null && this.securityClassificationsId !== undefined) {
      output.writeFieldBegin('securityClassificationsId', Thrift.Type.SET, 5);
      output.writeSetBegin(Thrift.Type.STRING, this.securityClassificationsId.length);
      for (let iter302 in this.securityClassificationsId) {
        if (this.securityClassificationsId.hasOwnProperty(iter302)) {
          iter302 = this.securityClassificationsId[iter302];
          output.writeString(iter302);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter303 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter303)) {
          iter303 = this.attachments[iter303];
          iter303.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.docRelations !== null && this.docRelations !== undefined) {
      output.writeFieldBegin('docRelations', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.docRelations.length);
      for (let iter304 in this.docRelations) {
        if (this.docRelations.hasOwnProperty(iter304)) {
          iter304 = this.docRelations[iter304];
          iter304.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xmlDoc = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xmlDoc !== undefined && args.xmlDoc !== null) {
        this.xmlDoc = args.xmlDoc;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xmlDoc = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xmlDoc !== null && this.xmlDoc !== undefined) {
      output.writeFieldBegin('xmlDoc', Thrift.Type.STRING, 2);
      output.writeBinary(this.xmlDoc);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createDocumentFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createDocumentFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.decrypt = null;
    this.executorsPortion = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.decrypt !== undefined && args.decrypt !== null) {
        this.decrypt = args.decrypt;
      }
      if (args.executorsPortion !== undefined && args.executorsPortion !== null) {
        this.executorsPortion = args.executorsPortion;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.BOOL) {
          this.decrypt = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.executorsPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.decrypt !== null && this.decrypt !== undefined) {
      output.writeFieldBegin('decrypt', Thrift.Type.BOOL, 4);
      output.writeBool(this.decrypt);
      output.writeFieldEnd();
    }
    if (this.executorsPortion !== null && this.executorsPortion !== undefined) {
      output.writeFieldBegin('executorsPortion', Thrift.Type.I32, 5);
      output.writeI32(this.executorsPortion);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3306 = input.readListBegin();
          const _size305 = _rtmp3306.size || 0;
          for (let _i307 = 0; _i307 < _size305; ++_i307) {
            let elem308 = null;
            elem308 = new Document();
            elem308.read(input);
            this.success.push(elem308);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter309 in this.success) {
        if (this.success.hasOwnProperty(iter309)) {
          iter309 = this.success[iter309];
          iter309.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_args = class {
  constructor(args) {
    this.token = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 2);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountAllDocuments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I32) {
          this.success = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountAllDocuments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I32, 0);
      output.writeI32(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllPassedStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [PassedStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3311 = input.readListBegin();
          const _size310 = _rtmp3311.size || 0;
          for (let _i312 = 0; _i312 < _size310; ++_i312) {
            let elem313 = null;
            elem313 = new PassedStage();
            elem313.read(input);
            this.success.push(elem313);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllPassedStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter314 in this.success) {
        if (this.success.hasOwnProperty(iter314)) {
          iter314 = this.success[iter314];
          iter314.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.iteration = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.iteration !== undefined && args.iteration !== null) {
        this.iteration = args.iteration;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.iteration = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.iteration !== null && this.iteration !== undefined) {
      output.writeFieldBegin('iteration', Thrift.Type.I32, 4);
      output.writeI32(this.iteration);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getExecutionTree_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ExecutionTree]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3316 = input.readListBegin();
          const _size315 = _rtmp3316.size || 0;
          for (let _i317 = 0; _i317 < _size315; ++_i317) {
            let elem318 = null;
            elem318 = new ExecutionTree();
            elem318.read(input);
            this.success.push(elem318);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getExecutionTree_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter319 in this.success) {
        if (this.success.hasOwnProperty(iter319)) {
          iter319 = this.success[iter319];
          iter319.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getActiveStages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentPatternStage]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3321 = input.readListBegin();
          const _size320 = _rtmp3321.size || 0;
          for (let _i322 = 0; _i322 < _size320; ++_i322) {
            let elem323 = null;
            elem323 = new DocumentPatternStage();
            elem323.read(input);
            this.success.push(elem323);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getActiveStages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter324 in this.success) {
        if (this.success.hasOwnProperty(iter324)) {
          iter324 = this.success[iter324];
          iter324.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountPeoplesWhenRenderedDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3326 = input.readMapBegin();
          const _size325 = _rtmp3326.size || 0;
          for (let _i327 = 0; _i327 < _size325; ++_i327) {
            if (_i327 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key328 = null;
            let val329 = null;
            key328 = input.readString().value;
            val329 = input.readI32().value;
            this.success[key328] = val329;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountPeoplesWhenRenderedDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter330 in this.success) {
        if (this.success.hasOwnProperty(kiter330)) {
          let viter331 = this.success[kiter330];
          output.writeString(kiter330);
          output.writeI32(viter331);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.signature = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3333 = input.readListBegin();
          const _size332 = _rtmp3333.size || 0;
          for (let _i334 = 0; _i334 < _size332; ++_i334) {
            let elem335 = null;
            elem335 = new AttCreateInfo();
            elem335.read(input);
            this.attachments.push(elem335);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3337 = input.readListBegin();
          const _size336 = _rtmp3337.size || 0;
          for (let _i338 = 0; _i338 < _size336; ++_i338) {
            let elem339 = null;
            elem339 = new ContentHolderLink();
            elem339.read(input);
            this.holderLinks.push(elem339);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 7);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter340 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter340)) {
          iter340 = this.attachments[iter340];
          iter340.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter341 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter341)) {
          iter341 = this.holderLinks[iter341];
          iter341.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 10);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.decision = null;
    this.documentComment = null;
    this.force = null;
    this.pKeyId = null;
    this.password = null;
    this.cardId = null;
    this.attachments = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.decision !== undefined && args.decision !== null) {
        this.decision = args.decision;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = args.documentComment;
      }
      if (args.force !== undefined && args.force !== null) {
        this.force = args.force;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.decision = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.documentComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.force = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3343 = input.readListBegin();
          const _size342 = _rtmp3343.size || 0;
          for (let _i344 = 0; _i344 < _size342; ++_i344) {
            let elem345 = null;
            elem345 = new AttCreateInfo();
            elem345.read(input);
            this.attachments.push(elem345);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3347 = input.readListBegin();
          const _size346 = _rtmp3347.size || 0;
          for (let _i348 = 0; _i348 < _size346; ++_i348) {
            let elem349 = null;
            elem349 = new ContentHolderLink();
            elem349.read(input);
            this.holderLinks.push(elem349);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.decision !== null && this.decision !== undefined) {
      output.writeFieldBegin('decision', Thrift.Type.STRING, 3);
      output.writeString(this.decision);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRING, 4);
      output.writeString(this.documentComment);
      output.writeFieldEnd();
    }
    if (this.force !== null && this.force !== undefined) {
      output.writeFieldBegin('force', Thrift.Type.BOOL, 5);
      output.writeBool(this.force);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 6);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 7);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 8);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 9);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter350 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter350)) {
          iter350 = this.attachments[iter350];
          iter350.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 10);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter351 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter351)) {
          iter351 = this.holderLinks[iter351];
          iter351.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 11);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentDecisionUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentDecisionUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_args = class {
  constructor(args) {
    this.token = null;
    this.executionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.executionId !== undefined && args.executionId !== null) {
        this.executionId = args.executionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.executionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.executionId !== null && this.executionId !== undefined) {
      output.writeFieldBegin('executionId', Thrift.Type.STRING, 2);
      output.writeString(this.executionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_approveDocumentDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_approveDocumentDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.usersOrGroups = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3353 = input.readListBegin();
          const _size352 = _rtmp3353.size || 0;
          for (let _i354 = 0; _i354 < _size352; ++_i354) {
            let elem355 = null;
            elem355 = new UserOrGroup();
            elem355.read(input);
            this.usersOrGroups.push(elem355);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter356 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter356)) {
          iter356 = this.usersOrGroups[iter356];
          iter356.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_shareDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3358 = input.readListBegin();
          const _size357 = _rtmp3358.size || 0;
          for (let _i359 = 0; _i359 < _size357; ++_i359) {
            let elem360 = null;
            elem360 = new DocumentExecution();
            elem360.read(input);
            this.success.push(elem360);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_shareDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter361 in this.success) {
        if (this.success.hasOwnProperty(iter361)) {
          iter361 = this.success[iter361];
          iter361.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.usersOrGroups = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.usersOrGroups !== undefined && args.usersOrGroups !== null) {
        this.usersOrGroups = Thrift.copyList(args.usersOrGroups, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.usersOrGroups = [];
          const _rtmp3363 = input.readListBegin();
          const _size362 = _rtmp3363.size || 0;
          for (let _i364 = 0; _i364 < _size362; ++_i364) {
            let elem365 = null;
            elem365 = new UserOrGroup();
            elem365.read(input);
            this.usersOrGroups.push(elem365);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.usersOrGroups !== null && this.usersOrGroups !== undefined) {
      output.writeFieldBegin('usersOrGroups', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.usersOrGroups.length);
      for (let iter366 in this.usersOrGroups) {
        if (this.usersOrGroups.hasOwnProperty(iter366)) {
          iter366 = this.usersOrGroups[iter366];
          iter366.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentSharings_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3368 = input.readListBegin();
          const _size367 = _rtmp3368.size || 0;
          for (let _i369 = 0; _i369 < _size367; ++_i369) {
            let elem370 = null;
            elem370 = new UserOrGroup();
            elem370.read(input);
            this.success.push(elem370);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentSharings_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter371 in this.success) {
        if (this.success.hasOwnProperty(iter371)) {
          iter371 = this.success[iter371];
          iter371.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentReassign]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3373 = input.readListBegin();
          const _size372 = _rtmp3373.size || 0;
          for (let _i374 = 0; _i374 < _size372; ++_i374) {
            let elem375 = null;
            elem375 = new DocumentReassign();
            elem375.read(input);
            this.success.push(elem375);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter376 in this.success) {
        if (this.success.hasOwnProperty(iter376)) {
          iter376 = this.success[iter376];
          iter376.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3378 = input.readListBegin();
          const _size377 = _rtmp3378.size || 0;
          for (let _i379 = 0; _i379 < _size377; ++_i379) {
            let elem380 = null;
            elem380 = new DocumentReassign();
            elem380.read(input);
            this.documentReassign.push(elem380);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter381 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter381)) {
          iter381 = this.documentReassign[iter381];
          iter381.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 5);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3383 = input.readListBegin();
          const _size382 = _rtmp3383.size || 0;
          for (let _i384 = 0; _i384 < _size382; ++_i384) {
            let elem385 = null;
            elem385 = new DocumentExecution();
            elem385.read(input);
            this.success.push(elem385);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter386 in this.success) {
        if (this.success.hasOwnProperty(iter386)) {
          iter386 = this.success[iter386];
          iter386.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentReassign = null;
    this.cardId = null;
    this.pKeyId = null;
    this.password = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.pKeyId !== undefined && args.pKeyId !== null) {
        this.pKeyId = args.pKeyId;
      }
      if (args.password !== undefined && args.password !== null) {
        this.password = args.password;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3388 = input.readListBegin();
          const _size387 = _rtmp3388.size || 0;
          for (let _i389 = 0; _i389 < _size387; ++_i389) {
            let elem390 = null;
            elem390 = new DocumentReassign();
            elem390.read(input);
            this.documentReassign.push(elem390);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRING) {
          this.pKeyId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.password = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter391 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter391)) {
          iter391 = this.documentReassign[iter391];
          iter391.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 4);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.pKeyId !== null && this.pKeyId !== undefined) {
      output.writeFieldBegin('pKeyId', Thrift.Type.STRING, 5);
      output.writeString(this.pKeyId);
      output.writeFieldEnd();
    }
    if (this.password !== null && this.password !== undefined) {
      output.writeFieldBegin('password', Thrift.Type.STRING, 6);
      output.writeString(this.password);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_reassignDocumentUsingServerKeyStorage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3393 = input.readListBegin();
          const _size392 = _rtmp3393.size || 0;
          for (let _i394 = 0; _i394 < _size392; ++_i394) {
            let elem395 = null;
            elem395 = new DocumentExecution();
            elem395.read(input);
            this.success.push(elem395);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_reassignDocumentUsingServerKeyStorage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter396 in this.success) {
        if (this.success.hasOwnProperty(iter396)) {
          iter396 = this.success[iter396];
          iter396.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.deleteCard = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.deleteCard !== undefined && args.deleteCard !== null) {
        this.deleteCard = args.deleteCard;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.deleteCard = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.deleteCard !== null && this.deleteCard !== undefined) {
      output.writeFieldBegin('deleteCard', Thrift.Type.BOOL, 3);
      output.writeBool(this.deleteCard);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeChildCards_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeChildCards_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = new DocumentReassign(args.documentReassign);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentReassign = new DocumentReassign();
          this.documentReassign.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.STRUCT, 2);
      this.documentReassign.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentReassign(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentReassign();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassignId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassignId !== undefined && args.documentReassignId !== null) {
        this.documentReassignId = args.documentReassignId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentReassignId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassignId !== null && this.documentReassignId !== undefined) {
      output.writeFieldBegin('documentReassignId', Thrift.Type.STRING, 2);
      output.writeString(this.documentReassignId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteAutomaticDocumentReassign_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteAutomaticDocumentReassign_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_args = class {
  constructor(args) {
    this.token = null;
    this.documentExecutionId = null;
    this.userId = null;
    this.reassignType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentExecutionId !== undefined && args.documentExecutionId !== null) {
        this.documentExecutionId = args.documentExecutionId;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
      if (args.reassignType !== undefined && args.reassignType !== null) {
        this.reassignType = args.reassignType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.reassignType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentExecutionId !== null && this.documentExecutionId !== undefined) {
      output.writeFieldBegin('documentExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.documentExecutionId);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 3);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    if (this.reassignType !== null && this.reassignType !== undefined) {
      output.writeFieldBegin('reassignType', Thrift.Type.I32, 4);
      output.writeI32(this.reassignType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeReassignControl_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeReassignControl_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.stageId = null;
    this.typeLink = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.stageId !== undefined && args.stageId !== null) {
        this.stageId = args.stageId;
      }
      if (args.typeLink !== undefined && args.typeLink !== null) {
        this.typeLink = args.typeLink;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.stageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.typeLink = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.stageId !== null && this.stageId !== undefined) {
      output.writeFieldBegin('stageId', Thrift.Type.STRING, 3);
      output.writeString(this.stageId);
      output.writeFieldEnd();
    }
    if (this.typeLink !== null && this.typeLink !== undefined) {
      output.writeFieldBegin('typeLink', Thrift.Type.I32, 4);
      output.writeI32(this.typeLink);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 5);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 6);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentExecutions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3398 = input.readListBegin();
          const _size397 = _rtmp3398.size || 0;
          for (let _i399 = 0; _i399 < _size397; ++_i399) {
            let elem400 = null;
            elem400 = new DocumentExecution();
            elem400.read(input);
            this.success.push(elem400);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentExecutions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter401 in this.success) {
        if (this.success.hasOwnProperty(iter401)) {
          iter401 = this.success[iter401];
          iter401.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.docExecutionId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docExecutionId !== undefined && args.docExecutionId !== null) {
        this.docExecutionId = args.docExecutionId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docExecutionId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docExecutionId !== null && this.docExecutionId !== undefined) {
      output.writeFieldBegin('docExecutionId', Thrift.Type.STRING, 2);
      output.writeString(this.docExecutionId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.toAdd = null;
    this.toClose = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentReassign]);
      }
      if (args.toClose !== undefined && args.toClose !== null) {
        this.toClose = Thrift.copyList(args.toClose, [null]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3403 = input.readListBegin();
          const _size402 = _rtmp3403.size || 0;
          for (let _i404 = 0; _i404 < _size402; ++_i404) {
            let elem405 = null;
            elem405 = new DocumentReassign();
            elem405.read(input);
            this.toAdd.push(elem405);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toClose = [];
          const _rtmp3407 = input.readListBegin();
          const _size406 = _rtmp3407.size || 0;
          for (let _i408 = 0; _i408 < _size406; ++_i408) {
            let elem409 = null;
            elem409 = input.readString().value;
            this.toClose.push(elem409);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter410 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter410)) {
          iter410 = this.toAdd[iter410];
          iter410.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toClose !== null && this.toClose !== undefined) {
      output.writeFieldBegin('toClose', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRING, this.toClose.length);
      for (let iter411 in this.toClose) {
        if (this.toClose.hasOwnProperty(iter411)) {
          iter411 = this.toClose[iter411];
          output.writeString(iter411);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeExecutorsForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeExecutorsForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    this.attCreateInfoList = null;
    this.processingType = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.attCreateInfoList !== undefined && args.attCreateInfoList !== null) {
        this.attCreateInfoList = Thrift.copyList(args.attCreateInfoList, [AttCreateInfo]);
      }
      if (args.processingType !== undefined && args.processingType !== null) {
        this.processingType = args.processingType;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.attCreateInfoList = [];
          const _rtmp3413 = input.readListBegin();
          const _size412 = _rtmp3413.size || 0;
          for (let _i414 = 0; _i414 < _size412; ++_i414) {
            let elem415 = null;
            elem415 = new AttCreateInfo();
            elem415.read(input);
            this.attCreateInfoList.push(elem415);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.I32) {
          this.processingType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.attCreateInfoList !== null && this.attCreateInfoList !== undefined) {
      output.writeFieldBegin('attCreateInfoList', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.attCreateInfoList.length);
      for (let iter416 in this.attCreateInfoList) {
        if (this.attCreateInfoList.hasOwnProperty(iter416)) {
          iter416 = this.attCreateInfoList[iter416];
          iter416.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.processingType !== null && this.processingType !== undefined) {
      output.writeFieldBegin('processingType', Thrift.Type.I32, 6);
      output.writeI32(this.processingType);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createAttachmentFrom_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3418 = input.readListBegin();
          const _size417 = _rtmp3418.size || 0;
          for (let _i419 = 0; _i419 < _size417; ++_i419) {
            let elem420 = null;
            elem420 = new Attachment();
            elem420.read(input);
            this.success.push(elem420);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createAttachmentFrom_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter421 in this.success) {
        if (this.success.hasOwnProperty(iter421)) {
          iter421 = this.success[iter421];
          iter421.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.fileName = null;
    this.totalSize = null;
    this.countPortions = null;
    this.cardId = null;
    this.attachmmentId = null;
    this.forDraft = null;
    this.accessPolicy = null;
    this.editMode = null;
    this.meetingId = null;
    this.extStatus = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.fileName !== undefined && args.fileName !== null) {
        this.fileName = args.fileName;
      }
      if (args.totalSize !== undefined && args.totalSize !== null) {
        this.totalSize = args.totalSize;
      }
      if (args.countPortions !== undefined && args.countPortions !== null) {
        this.countPortions = args.countPortions;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.attachmmentId !== undefined && args.attachmmentId !== null) {
        this.attachmmentId = args.attachmmentId;
      }
      if (args.forDraft !== undefined && args.forDraft !== null) {
        this.forDraft = args.forDraft;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
      if (args.meetingId !== undefined && args.meetingId !== null) {
        this.meetingId = args.meetingId;
      }
      if (args.extStatus !== undefined && args.extStatus !== null) {
        this.extStatus = args.extStatus;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.fileName = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.totalSize = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.I32) {
          this.countPortions = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.STRING) {
          this.attachmmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.BOOL) {
          this.forDraft = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 10:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 11:
        if (ftype == Thrift.Type.STRING) {
          this.meetingId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 12:
        if (ftype == Thrift.Type.I32) {
          this.extStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.fileName !== null && this.fileName !== undefined) {
      output.writeFieldBegin('fileName', Thrift.Type.STRING, 3);
      output.writeString(this.fileName);
      output.writeFieldEnd();
    }
    if (this.totalSize !== null && this.totalSize !== undefined) {
      output.writeFieldBegin('totalSize', Thrift.Type.I64, 4);
      output.writeI64(this.totalSize);
      output.writeFieldEnd();
    }
    if (this.countPortions !== null && this.countPortions !== undefined) {
      output.writeFieldBegin('countPortions', Thrift.Type.I32, 5);
      output.writeI32(this.countPortions);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 6);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.attachmmentId !== null && this.attachmmentId !== undefined) {
      output.writeFieldBegin('attachmmentId', Thrift.Type.STRING, 7);
      output.writeString(this.attachmmentId);
      output.writeFieldEnd();
    }
    if (this.forDraft !== null && this.forDraft !== undefined) {
      output.writeFieldBegin('forDraft', Thrift.Type.BOOL, 8);
      output.writeBool(this.forDraft);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 9);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 10);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    if (this.meetingId !== null && this.meetingId !== undefined) {
      output.writeFieldBegin('meetingId', Thrift.Type.STRING, 11);
      output.writeString(this.meetingId);
      output.writeFieldEnd();
    }
    if (this.extStatus !== null && this.extStatus !== undefined) {
      output.writeFieldBegin('extStatus', Thrift.Type.I32, 12);
      output.writeI32(this.extStatus);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createLoadableAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createLoadableAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.numberPortion = null;
    this.fileContentBytes = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.numberPortion !== undefined && args.numberPortion !== null) {
        this.numberPortion = args.numberPortion;
      }
      if (args.fileContentBytes !== undefined && args.fileContentBytes !== null) {
        this.fileContentBytes = args.fileContentBytes;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.numberPortion = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.fileContentBytes = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.numberPortion !== null && this.numberPortion !== undefined) {
      output.writeFieldBegin('numberPortion', Thrift.Type.I32, 3);
      output.writeI32(this.numberPortion);
      output.writeFieldEnd();
    }
    if (this.fileContentBytes !== null && this.fileContentBytes !== undefined) {
      output.writeFieldBegin('fileContentBytes', Thrift.Type.STRING, 4);
      output.writeBinary(this.fileContentBytes);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_uploadDocumentAttachmentPortions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_uploadDocumentAttachmentPortions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.attachmentType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.attachmentType !== undefined && args.attachmentType !== null) {
        this.attachmentType = args.attachmentType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.attachmentType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.attachmentType !== null && this.attachmentType !== undefined) {
      output.writeFieldBegin('attachmentType', Thrift.Type.I32, 3);
      output.writeI32(this.attachmentType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_downloadDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_downloadDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.pages = null;
    this.angle = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.pages !== undefined && args.pages !== null) {
        this.pages = args.pages;
      }
      if (args.angle !== undefined && args.angle !== null) {
        this.angle = args.angle;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.pages = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.angle = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.pages !== null && this.pages !== undefined) {
      output.writeFieldBegin('pages', Thrift.Type.STRING, 3);
      output.writeString(this.pages);
      output.writeFieldEnd();
    }
    if (this.angle !== null && this.angle !== undefined) {
      output.writeFieldBegin('angle', Thrift.Type.I32, 4);
      output.writeI32(this.angle);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_rotatePdfPages_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_rotatePdfPages_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.attachments = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.attachments !== undefined && args.attachments !== null) {
        this.attachments = Thrift.copyList(args.attachments, [AttCreateInfo]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.attachments = [];
          const _rtmp3423 = input.readListBegin();
          const _size422 = _rtmp3423.size || 0;
          for (let _i424 = 0; _i424 < _size422; ++_i424) {
            let elem425 = null;
            elem425 = new AttCreateInfo();
            elem425.read(input);
            this.attachments.push(elem425);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.attachments !== null && this.attachments !== undefined) {
      output.writeFieldBegin('attachments', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.attachments.length);
      for (let iter426 in this.attachments) {
        if (this.attachments.hasOwnProperty(iter426)) {
          iter426 = this.attachments[iter426];
          iter426.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAttachmentsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAttachmentsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.removeOldVersions = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.removeOldVersions !== undefined && args.removeOldVersions !== null) {
        this.removeOldVersions = args.removeOldVersions;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.removeOldVersions = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.removeOldVersions !== null && this.removeOldVersions !== undefined) {
      output.writeFieldBegin('removeOldVersions', Thrift.Type.BOOL, 3);
      output.writeBool(this.removeOldVersions);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeDocumentAttachment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeDocumentAttachment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markAsWaitForPublish_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markAsWaitForPublish_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.editMode = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.editMode !== undefined && args.editMode !== null) {
        this.editMode = args.editMode;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.editMode = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.editMode !== null && this.editMode !== undefined) {
      output.writeFieldBegin('editMode', Thrift.Type.I32, 3);
      output.writeI32(this.editMode);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentEditMode_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentEditMode_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.latestOnly = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.latestOnly !== undefined && args.latestOnly !== null) {
        this.latestOnly = args.latestOnly;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.latestOnly = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.latestOnly !== null && this.latestOnly !== undefined) {
      output.writeFieldBegin('latestOnly', Thrift.Type.BOOL, 3);
      output.writeBool(this.latestOnly);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3428 = input.readListBegin();
          const _size427 = _rtmp3428.size || 0;
          for (let _i429 = 0; _i429 < _size427; ++_i429) {
            let elem430 = null;
            elem430 = new Attachment();
            elem430.read(input);
            this.success.push(elem430);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter431 in this.success) {
        if (this.success.hasOwnProperty(iter431)) {
          iter431 = this.success[iter431];
          iter431.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentAttachmentById_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentAttachmentById_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_args = class {
  constructor(args) {
    this.token = null;
    this.attachmentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.attachmentId !== undefined && args.attachmentId !== null) {
        this.attachmentId = args.attachmentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.attachmentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.attachmentId !== null && this.attachmentId !== undefined) {
      output.writeFieldBegin('attachmentId', Thrift.Type.STRING, 2);
      output.writeString(this.attachmentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentAttachmentVersions_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Attachment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3433 = input.readListBegin();
          const _size432 = _rtmp3433.size || 0;
          for (let _i434 = 0; _i434 < _size432; ++_i434) {
            let elem435 = null;
            elem435 = new Attachment();
            elem435.read(input);
            this.success.push(elem435);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentAttachmentVersions_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter436 in this.success) {
        if (this.success.hasOwnProperty(iter436)) {
          iter436 = this.success[iter436];
          iter436.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_args = class {
  constructor(args) {
    this.token = null;
    this.toHideList = null;
    this.toShowList = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toHideList !== undefined && args.toHideList !== null) {
        this.toHideList = Thrift.copyList(args.toHideList, [null]);
      }
      if (args.toShowList !== undefined && args.toShowList !== null) {
        this.toShowList = Thrift.copyList(args.toShowList, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toHideList = [];
          const _rtmp3438 = input.readListBegin();
          const _size437 = _rtmp3438.size || 0;
          for (let _i439 = 0; _i439 < _size437; ++_i439) {
            let elem440 = null;
            elem440 = input.readString().value;
            this.toHideList.push(elem440);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toShowList = [];
          const _rtmp3442 = input.readListBegin();
          const _size441 = _rtmp3442.size || 0;
          for (let _i443 = 0; _i443 < _size441; ++_i443) {
            let elem444 = null;
            elem444 = input.readString().value;
            this.toShowList.push(elem444);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toHideList !== null && this.toHideList !== undefined) {
      output.writeFieldBegin('toHideList', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.toHideList.length);
      for (let iter445 in this.toHideList) {
        if (this.toHideList.hasOwnProperty(iter445)) {
          iter445 = this.toHideList[iter445];
          output.writeString(iter445);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toShowList !== null && this.toShowList !== undefined) {
      output.writeFieldBegin('toShowList', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toShowList.length);
      for (let iter446 in this.toShowList) {
        if (this.toShowList.hasOwnProperty(iter446)) {
          iter446 = this.toShowList[iter446];
          output.writeString(iter446);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentsVisibility_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentsVisibility_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentComment = null;
    this.addToComment = null;
    this.changeType = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentComment !== undefined && args.documentComment !== null) {
        this.documentComment = new DocumentComment(args.documentComment);
      }
      if (args.addToComment !== undefined && args.addToComment !== null) {
        this.addToComment = args.addToComment;
      }
      if (args.changeType !== undefined && args.changeType !== null) {
        this.changeType = args.changeType;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentComment = new DocumentComment();
          this.documentComment.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.addToComment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I32) {
          this.changeType = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentComment !== null && this.documentComment !== undefined) {
      output.writeFieldBegin('documentComment', Thrift.Type.STRUCT, 2);
      this.documentComment.write(output);
      output.writeFieldEnd();
    }
    if (this.addToComment !== null && this.addToComment !== undefined) {
      output.writeFieldBegin('addToComment', Thrift.Type.STRING, 3);
      output.writeString(this.addToComment);
      output.writeFieldEnd();
    }
    if (this.changeType !== null && this.changeType !== undefined) {
      output.writeFieldBegin('changeType', Thrift.Type.I32, 4);
      output.writeI32(this.changeType);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentComment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentComment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentComments_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentComment]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3448 = input.readListBegin();
          const _size447 = _rtmp3448.size || 0;
          for (let _i449 = 0; _i449 < _size447; ++_i449) {
            let elem450 = null;
            elem450 = new DocumentComment();
            elem450.read(input);
            this.success.push(elem450);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentComments_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter451 in this.success) {
        if (this.success.hasOwnProperty(iter451)) {
          iter451 = this.success[iter451];
          iter451.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_args = class {
  constructor(args) {
    this.token = null;
    this.documentCommentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentCommentId !== undefined && args.documentCommentId !== null) {
        this.documentCommentId = args.documentCommentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentCommentId !== null && this.documentCommentId !== undefined) {
      output.writeFieldBegin('documentCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentCommentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.holderLinks = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.holderLinks !== undefined && args.holderLinks !== null) {
        this.holderLinks = Thrift.copyList(args.holderLinks, [ContentHolderLink]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.holderLinks = [];
          const _rtmp3453 = input.readListBegin();
          const _size452 = _rtmp3453.size || 0;
          for (let _i454 = 0; _i454 < _size452; ++_i454) {
            let elem455 = null;
            elem455 = new ContentHolderLink();
            elem455.read(input);
            this.holderLinks.push(elem455);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.holderLinks !== null && this.holderLinks !== undefined) {
      output.writeFieldBegin('holderLinks', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.holderLinks.length);
      for (let iter456 in this.holderLinks) {
        if (this.holderLinks.hasOwnProperty(iter456)) {
          iter456 = this.holderLinks[iter456];
          iter456.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentHolderLink_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentHolderShowPlace]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3458 = input.readListBegin();
          const _size457 = _rtmp3458.size || 0;
          for (let _i459 = 0; _i459 < _size457; ++_i459) {
            let elem460 = null;
            elem460 = new ContentHolderShowPlace();
            elem460.read(input);
            this.success.push(elem460);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentHolderLink_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter461 in this.success) {
        if (this.success.hasOwnProperty(iter461)) {
          iter461 = this.success[iter461];
          iter461.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentContentTab = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentContentTab !== undefined && args.documentContentTab !== null) {
        this.documentContentTab = new ContentTab(args.documentContentTab);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.documentContentTab = new ContentTab();
          this.documentContentTab.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentContentTab !== null && this.documentContentTab !== undefined) {
      output.writeFieldBegin('documentContentTab', Thrift.Type.STRUCT, 3);
      this.documentContentTab.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createOrUpdateDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new ContentTab(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new ContentTab();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createOrUpdateDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentContentTabsByFilter_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentTab]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3463 = input.readListBegin();
          const _size462 = _rtmp3463.size || 0;
          for (let _i464 = 0; _i464 < _size462; ++_i464) {
            let elem465 = null;
            elem465 = new ContentTab();
            elem465.read(input);
            this.success.push(elem465);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentContentTabsByFilter_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter466 in this.success) {
        if (this.success.hasOwnProperty(iter466)) {
          iter466 = this.success[iter466];
          iter466.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_args = class {
  constructor(args) {
    this.token = null;
    this.documentContentTabId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentContentTabId !== undefined && args.documentContentTabId !== null) {
        this.documentContentTabId = args.documentContentTabId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentContentTabId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentContentTabId !== null && this.documentContentTabId !== undefined) {
      output.writeFieldBegin('documentContentTabId', Thrift.Type.STRING, 2);
      output.writeString(this.documentContentTabId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_deleteDocumentContentTab_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_deleteDocumentContentTab_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_documentToArchive_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_documentToArchive_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [UserOrGroup]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.SET) {
          this.success = [];
          const _rtmp3468 = input.readSetBegin();
          const _size467 = _rtmp3468.size || 0;
          for (let _i469 = 0; _i469 < _size467; ++_i469) {
            let elem470 = null;
            elem470 = new UserOrGroup();
            elem470.read(input);
            this.success.push(elem470);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.SET, 0);
      output.writeSetBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter471 in this.success) {
        if (this.success.hasOwnProperty(iter471)) {
          iter471 = this.success[iter471];
          iter471.write(output);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3473 = input.readListBegin();
          const _size472 = _rtmp3473.size || 0;
          for (let _i474 = 0; _i474 < _size472; ++_i474) {
            let elem475 = null;
            elem475 = new UserOrGroup();
            elem475.read(input);
            this.users.push(elem475);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter476 in this.users) {
        if (this.users.hasOwnProperty(iter476)) {
          iter476 = this.users[iter476];
          iter476.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.users = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [UserOrGroup]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3478 = input.readListBegin();
          const _size477 = _rtmp3478.size || 0;
          for (let _i479 = 0; _i479 < _size477; ++_i479) {
            let elem480 = null;
            elem480 = new UserOrGroup();
            elem480.read(input);
            this.users.push(elem480);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.users.length);
      for (let iter481 in this.users) {
        if (this.users.hasOwnProperty(iter481)) {
          iter481 = this.users[iter481];
          iter481.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeResponsibleForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeResponsibleForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocHistoryPage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new HistoryPage(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new HistoryPage();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocHistoryPage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllNews_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [News]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3483 = input.readListBegin();
          const _size482 = _rtmp3483.size || 0;
          for (let _i484 = 0; _i484 < _size482; ++_i484) {
            let elem485 = null;
            elem485 = new News();
            elem485.read(input);
            this.success.push(elem485);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllNews_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter486 in this.success) {
        if (this.success.hasOwnProperty(iter486)) {
          iter486 = this.success[iter486];
          iter486.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_args = class {
  constructor(args) {
    this.token = null;
    this.date = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.date !== undefined && args.date !== null) {
        this.date = args.date;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.I64) {
          this.date = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.date !== null && this.date !== undefined) {
      output.writeFieldBegin('date', Thrift.Type.I64, 2);
      output.writeI64(this.date);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTasksByDate_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3488 = input.readMapBegin();
          const _size487 = _rtmp3488.size || 0;
          for (let _i489 = 0; _i489 < _size487; ++_i489) {
            if (_i489 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key490 = null;
            let val491 = null;
            key490 = input.readI32().value;
            val491 = input.readI32().value;
            this.success[key490] = val491;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTasksByDate_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter492 in this.success) {
        if (this.success.hasOwnProperty(kiter492)) {
          let viter493 = this.success[kiter492];
          output.writeI32(kiter492);
          output.writeI32(viter493);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.docNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.docNumber !== undefined && args.docNumber !== null) {
        this.docNumber = args.docNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.docNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.docNumber !== null && this.docNumber !== undefined) {
      output.writeFieldBegin('docNumber', Thrift.Type.STRING, 3);
      output.writeString(this.docNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_generateDocumentNumber_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_generateDocumentNumber_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.viewed = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.viewed !== undefined && args.viewed !== null) {
        this.viewed = args.viewed;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.viewed = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.viewed !== null && this.viewed !== undefined) {
      output.writeFieldBegin('viewed', Thrift.Type.BOOL, 3);
      output.writeBool(this.viewed);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setDocumentViewed_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setDocumentViewed_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.filter = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllDocumentRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3495 = input.readListBegin();
          const _size494 = _rtmp3495.size || 0;
          for (let _i496 = 0; _i496 < _size494; ++_i496) {
            let elem497 = null;
            elem497 = new DocumentRelation();
            elem497.read(input);
            this.success.push(elem497);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllDocumentRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter498 in this.success) {
        if (this.success.hasOwnProperty(iter498)) {
          iter498 = this.success[iter498];
          iter498.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_args = class {
  constructor(args) {
    this.token = null;
    this.toCreate = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.toCreate !== undefined && args.toCreate !== null) {
        this.toCreate = Thrift.copyList(args.toCreate, [DocumentRelation]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.toCreate = [];
          const _rtmp3500 = input.readListBegin();
          const _size499 = _rtmp3500.size || 0;
          for (let _i501 = 0; _i501 < _size499; ++_i501) {
            let elem502 = null;
            elem502 = new DocumentRelation();
            elem502.read(input);
            this.toCreate.push(elem502);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3504 = input.readListBegin();
          const _size503 = _rtmp3504.size || 0;
          for (let _i505 = 0; _i505 < _size503; ++_i505) {
            let elem506 = null;
            elem506 = input.readString().value;
            this.toRemove.push(elem506);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.toCreate !== null && this.toCreate !== undefined) {
      output.writeFieldBegin('toCreate', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.toCreate.length);
      for (let iter507 in this.toCreate) {
        if (this.toCreate.hasOwnProperty(iter507)) {
          iter507 = this.toCreate[iter507];
          iter507.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter508 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter508)) {
          iter508 = this.toRemove[iter508];
          output.writeString(iter508);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRelations_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentRelation]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3510 = input.readListBegin();
          const _size509 = _rtmp3510.size || 0;
          for (let _i511 = 0; _i511 < _size509; ++_i511) {
            let elem512 = null;
            elem512 = new DocumentRelation();
            elem512.read(input);
            this.success.push(elem512);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRelations_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter513 in this.success) {
        if (this.success.hasOwnProperty(iter513)) {
          iter513 = this.success[iter513];
          iter513.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.subStatus = null;
    this.comment = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.subStatus !== undefined && args.subStatus !== null) {
        this.subStatus = args.subStatus;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I32) {
          this.subStatus = input.readI32().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.subStatus !== null && this.subStatus !== undefined) {
      output.writeFieldBegin('subStatus', Thrift.Type.I32, 3);
      output.writeI32(this.subStatus);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeSubStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeSubStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.documentExecution = null;
    this.deadlineTime = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.documentExecution !== undefined && args.documentExecution !== null) {
        this.documentExecution = args.documentExecution;
      }
      if (args.deadlineTime !== undefined && args.deadlineTime !== null) {
        this.deadlineTime = args.deadlineTime;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.documentExecution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineTime = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.documentExecution !== null && this.documentExecution !== undefined) {
      output.writeFieldBegin('documentExecution', Thrift.Type.STRING, 3);
      output.writeString(this.documentExecution);
      output.writeFieldEnd();
    }
    if (this.deadlineTime !== null && this.deadlineTime !== undefined) {
      output.writeFieldBegin('deadlineTime', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineTime);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.users = null;
    this.deadlineDate = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.users !== undefined && args.users !== null) {
        this.users = Thrift.copyList(args.users, [null]);
      }
      if (args.deadlineDate !== undefined && args.deadlineDate !== null) {
        this.deadlineDate = args.deadlineDate;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.users = [];
          const _rtmp3515 = input.readListBegin();
          const _size514 = _rtmp3515.size || 0;
          for (let _i516 = 0; _i516 < _size514; ++_i516) {
            let elem517 = null;
            elem517 = input.readString().value;
            this.users.push(elem517);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.I64) {
          this.deadlineDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.users !== null && this.users !== undefined) {
      output.writeFieldBegin('users', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.users.length);
      for (let iter518 in this.users) {
        if (this.users.hasOwnProperty(iter518)) {
          iter518 = this.users[iter518];
          output.writeString(iter518);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.deadlineDate !== null && this.deadlineDate !== undefined) {
      output.writeFieldBegin('deadlineDate', Thrift.Type.I64, 4);
      output.writeI64(this.deadlineDate);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addAdditionalConfirmers_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addAdditionalConfirmers_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_args = class {
  constructor(args) {
    this.token = null;
    this.userDecision = null;
    this.cardId = null;
    this.comment = null;
    this.returnToParentStage = null;
    this.signature = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userDecision !== undefined && args.userDecision !== null) {
        this.userDecision = Thrift.copyMap(args.userDecision, [null]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.returnToParentStage !== undefined && args.returnToParentStage !== null) {
        this.returnToParentStage = args.returnToParentStage;
      }
      if (args.signature !== undefined && args.signature !== null) {
        this.signature = args.signature;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.userDecision = {};
          const _rtmp3520 = input.readMapBegin();
          const _size519 = _rtmp3520.size || 0;
          for (let _i521 = 0; _i521 < _size519; ++_i521) {
            if (_i521 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key522 = null;
            let val523 = null;
            key522 = input.readString().value;
            val523 = input.readString().value;
            this.userDecision[key522] = val523;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.BOOL) {
          this.returnToParentStage = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.STRING) {
          this.signature = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userDecision !== null && this.userDecision !== undefined) {
      output.writeFieldBegin('userDecision', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.STRING, Thrift.objectLength(this.userDecision));
      for (let kiter524 in this.userDecision) {
        if (this.userDecision.hasOwnProperty(kiter524)) {
          let viter525 = this.userDecision[kiter524];
          output.writeString(kiter524);
          output.writeString(viter525);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.returnToParentStage !== null && this.returnToParentStage !== undefined) {
      output.writeFieldBegin('returnToParentStage', Thrift.Type.BOOL, 5);
      output.writeBool(this.returnToParentStage);
      output.writeFieldEnd();
    }
    if (this.signature !== null && this.signature !== undefined) {
      output.writeFieldBegin('signature', Thrift.Type.STRING, 6);
      output.writeString(this.signature);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_setAdditionalDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_setAdditionalDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_args = class {
  constructor(args) {
    this.token = null;
    this.documentReassign = null;
    this.cardId = null;
    this.comment = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3527 = input.readListBegin();
          const _size526 = _rtmp3527.size || 0;
          for (let _i528 = 0; _i528 < _size526; ++_i528) {
            let elem529 = null;
            elem529 = new DocumentReassign();
            elem529.read(input);
            this.documentReassign.push(elem529);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter530 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter530)) {
          iter530 = this.documentReassign[iter530];
          iter530.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 4);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_revokeDecision_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_revokeDecision_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.cardId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 3);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_markDecisionAsRemoved_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentExecution(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentExecution();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_markDecisionAsRemoved_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_args = class {
  constructor(args) {
    this.token = null;
    this.userId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.userId !== undefined && args.userId !== null) {
        this.userId = args.userId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.userId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.userId !== null && this.userId !== undefined) {
      output.writeFieldBegin('userId', Thrift.Type.STRING, 2);
      output.writeString(this.userId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getAllOpenDocumentExecutionsStatistic_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyMap(args.success, [null]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.MAP) {
          this.success = {};
          const _rtmp3532 = input.readMapBegin();
          const _size531 = _rtmp3532.size || 0;
          for (let _i533 = 0; _i533 < _size531; ++_i533) {
            if (_i533 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key534 = null;
            let val535 = null;
            key534 = input.readI32().value;
            val535 = input.readI32().value;
            this.success[key534] = val535;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getAllOpenDocumentExecutionsStatistic_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.MAP, 0);
      output.writeMapBegin(Thrift.Type.I32, Thrift.Type.I32, Thrift.objectLength(this.success));
      for (let kiter536 in this.success) {
        if (this.success.hasOwnProperty(kiter536)) {
          let viter537 = this.success[kiter536];
          output.writeI32(kiter536);
          output.writeI32(viter537);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.control = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.control !== undefined && args.control !== null) {
        this.control = args.control;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.BOOL) {
          this.control = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.control !== null && this.control !== undefined) {
      output.writeFieldBegin('control', Thrift.Type.BOOL, 3);
      output.writeBool(this.control);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeControlForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeControlForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.tags = [];
          const _rtmp3539 = input.readSetBegin();
          const _size538 = _rtmp3539.size || 0;
          for (let _i540 = 0; _i540 < _size538; ++_i540) {
            let elem541 = null;
            elem541 = input.readString().value;
            this.tags.push(elem541);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter542 in this.tags) {
        if (this.tags.hasOwnProperty(iter542)) {
          iter542 = this.tags[iter542];
          output.writeString(iter542);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.tags = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.tags !== undefined && args.tags !== null) {
        this.tags = Thrift.copyList(args.tags, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.SET) {
          this.tags = [];
          const _rtmp3544 = input.readSetBegin();
          const _size543 = _rtmp3544.size || 0;
          for (let _i545 = 0; _i545 < _size543; ++_i545) {
            let elem546 = null;
            elem546 = input.readString().value;
            this.tags.push(elem546);
          }
          input.readSetEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.tags !== null && this.tags !== undefined) {
      output.writeFieldBegin('tags', Thrift.Type.SET, 3);
      output.writeSetBegin(Thrift.Type.STRING, this.tags.length);
      for (let iter547 in this.tags) {
        if (this.tags.hasOwnProperty(iter547)) {
          iter547 = this.tags[iter547];
          output.writeString(iter547);
        }
      }
      output.writeSetEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_removeTagsToDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_removeTagsToDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.documentReassign = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.documentReassign !== undefined && args.documentReassign !== null) {
        this.documentReassign = Thrift.copyList(args.documentReassign, [DocumentReassign]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.LIST) {
          this.documentReassign = [];
          const _rtmp3549 = input.readListBegin();
          const _size548 = _rtmp3549.size || 0;
          for (let _i550 = 0; _i550 < _size548; ++_i550) {
            let elem551 = null;
            elem551 = new DocumentReassign();
            elem551.read(input);
            this.documentReassign.push(elem551);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.documentReassign !== null && this.documentReassign !== undefined) {
      output.writeFieldBegin('documentReassign', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRUCT, this.documentReassign.length);
      for (let iter552 in this.documentReassign) {
        if (this.documentReassign.hasOwnProperty(iter552)) {
          iter552 = this.documentReassign[iter552];
          iter552.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 4);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_addExecutorsToStage_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExecution]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3554 = input.readListBegin();
          const _size553 = _rtmp3554.size || 0;
          for (let _i555 = 0; _i555 < _size553; ++_i555) {
            let elem556 = null;
            elem556 = new DocumentExecution();
            elem556.read(input);
            this.success.push(elem556);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_addExecutorsToStage_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter557 in this.success) {
        if (this.success.hasOwnProperty(iter557)) {
          iter557 = this.success[iter557];
          iter557.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.patternGroupId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.patternGroupId !== undefined && args.patternGroupId !== null) {
        this.patternGroupId = args.patternGroupId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.patternGroupId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.patternGroupId !== null && this.patternGroupId !== undefined) {
      output.writeFieldBegin('patternGroupId', Thrift.Type.STRING, 2);
      output.writeString(this.patternGroupId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getCountDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.I64) {
          this.success = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getCountDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.I64, 0);
      output.writeI64(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_args = class {
  constructor(args) {
    this.token = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 2);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getTinyDocsByFilterNoPermission_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [Document]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3559 = input.readListBegin();
          const _size558 = _rtmp3559.size || 0;
          for (let _i560 = 0; _i560 < _size558; ++_i560) {
            let elem561 = null;
            elem561 = new Document();
            elem561.read(input);
            this.success.push(elem561);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getTinyDocsByFilterNoPermission_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter562 in this.success) {
        if (this.success.hasOwnProperty(iter562)) {
          iter562 = this.success[iter562];
          iter562.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.newRegistrationDate = null;
    this.newRegistrationNumber = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.newRegistrationDate !== undefined && args.newRegistrationDate !== null) {
        this.newRegistrationDate = args.newRegistrationDate;
      }
      if (args.newRegistrationNumber !== undefined && args.newRegistrationNumber !== null) {
        this.newRegistrationNumber = args.newRegistrationNumber;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.I64) {
          this.newRegistrationDate = input.readI64().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRING) {
          this.newRegistrationNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.newRegistrationDate !== null && this.newRegistrationDate !== undefined) {
      output.writeFieldBegin('newRegistrationDate', Thrift.Type.I64, 3);
      output.writeI64(this.newRegistrationDate);
      output.writeFieldEnd();
    }
    if (this.newRegistrationNumber !== null && this.newRegistrationNumber !== undefined) {
      output.writeFieldBegin('newRegistrationNumber', Thrift.Type.STRING, 4);
      output.writeString(this.newRegistrationNumber);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 5);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeRegistrationInfoForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeRegistrationInfoForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_createChatForDocument_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_createChatForDocument_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeString(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 4);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentExtShareList_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3564 = input.readListBegin();
          const _size563 = _rtmp3564.size || 0;
          for (let _i565 = 0; _i565 < _size563; ++_i565) {
            let elem566 = null;
            elem566 = new DocumentExtShare();
            elem566.read(input);
            this.success.push(elem566);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentExtShareList_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter567 in this.success) {
        if (this.success.hasOwnProperty(iter567)) {
          iter567 = this.success[iter567];
          iter567.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    this.toAdd = null;
    this.toRemove = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.toAdd !== undefined && args.toAdd !== null) {
        this.toAdd = Thrift.copyList(args.toAdd, [DocumentExtShare]);
      }
      if (args.toRemove !== undefined && args.toRemove !== null) {
        this.toRemove = Thrift.copyList(args.toRemove, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.toAdd = [];
          const _rtmp3569 = input.readListBegin();
          const _size568 = _rtmp3569.size || 0;
          for (let _i570 = 0; _i570 < _size568; ++_i570) {
            let elem571 = null;
            elem571 = new DocumentExtShare();
            elem571.read(input);
            this.toAdd.push(elem571);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.toRemove = [];
          const _rtmp3573 = input.readListBegin();
          const _size572 = _rtmp3573.size || 0;
          for (let _i574 = 0; _i574 < _size572; ++_i574) {
            let elem575 = null;
            elem575 = input.readString().value;
            this.toRemove.push(elem575);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.toAdd !== null && this.toAdd !== undefined) {
      output.writeFieldBegin('toAdd', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.toAdd.length);
      for (let iter576 in this.toAdd) {
        if (this.toAdd.hasOwnProperty(iter576)) {
          iter576 = this.toAdd[iter576];
          iter576.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.toRemove !== null && this.toRemove !== undefined) {
      output.writeFieldBegin('toRemove', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRING, this.toRemove.length);
      for (let iter577 in this.toRemove) {
        if (this.toRemove.hasOwnProperty(iter577)) {
          iter577 = this.toRemove[iter577];
          output.writeString(iter577);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentExtShare_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [DocumentExtShare]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3579 = input.readListBegin();
          const _size578 = _rtmp3579.size || 0;
          for (let _i580 = 0; _i580 < _size578; ++_i580) {
            let elem581 = null;
            elem581 = new DocumentExtShare();
            elem581.read(input);
            this.success.push(elem581);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentExtShare_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter582 in this.success) {
        if (this.success.hasOwnProperty(iter582)) {
          iter582 = this.success[iter582];
          iter582.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_args = class {
  constructor(args) {
    this.token = null;
    this.statusMap = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.statusMap !== undefined && args.statusMap !== null) {
        this.statusMap = Thrift.copyMap(args.statusMap, [null]);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.MAP) {
          this.statusMap = {};
          const _rtmp3584 = input.readMapBegin();
          const _size583 = _rtmp3584.size || 0;
          for (let _i585 = 0; _i585 < _size583; ++_i585) {
            if (_i585 > 0 ) {
              if (input.rstack.length > input.rpos[input.rpos.length -1] + 1) {
                input.rstack.pop();
              }
            }
            let key586 = null;
            let val587 = null;
            key586 = input.readString().value;
            val587 = input.readI32().value;
            this.statusMap[key586] = val587;
          }
          input.readMapEnd();
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.statusMap !== null && this.statusMap !== undefined) {
      output.writeFieldBegin('statusMap', Thrift.Type.MAP, 2);
      output.writeMapBegin(Thrift.Type.STRING, Thrift.Type.I32, Thrift.objectLength(this.statusMap));
      for (let kiter588 in this.statusMap) {
        if (this.statusMap.hasOwnProperty(kiter588)) {
          let viter589 = this.statusMap[kiter588];
          output.writeString(kiter588);
          output.writeI32(viter589);
        }
      }
      output.writeMapEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeAttachmentExtStatus_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeAttachmentExtStatus_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_remindDocumentExecutor_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_remindDocumentExecutor_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_args = class {
  constructor(args) {
    this.token = null;
    this.cardId = null;
    this.resolution = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.cardId !== undefined && args.cardId !== null) {
        this.cardId = args.cardId;
      }
      if (args.resolution !== undefined && args.resolution !== null) {
        this.resolution = args.resolution;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.cardId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.resolution = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.cardId !== null && this.cardId !== undefined) {
      output.writeFieldBegin('cardId', Thrift.Type.STRING, 2);
      output.writeString(this.cardId);
      output.writeFieldEnd();
    }
    if (this.resolution !== null && this.resolution !== undefined) {
      output.writeFieldBegin('resolution', Thrift.Type.STRING, 3);
      output.writeString(this.resolution);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateReassignResolution_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateReassignResolution_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_args = class {
  constructor(args) {
    this.token = null;
    this.docCommentId = null;
    this.comment = null;
    this.policy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docCommentId !== undefined && args.docCommentId !== null) {
        this.docCommentId = args.docCommentId;
      }
      if (args.comment !== undefined && args.comment !== null) {
        this.comment = args.comment;
      }
      if (args.policy !== undefined && args.policy !== null) {
        this.policy = new DocumentAccessPolicy(args.policy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docCommentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.comment = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.STRUCT) {
          this.policy = new DocumentAccessPolicy();
          this.policy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docCommentId !== null && this.docCommentId !== undefined) {
      output.writeFieldBegin('docCommentId', Thrift.Type.STRING, 2);
      output.writeString(this.docCommentId);
      output.writeFieldEnd();
    }
    if (this.comment !== null && this.comment !== undefined) {
      output.writeFieldBegin('comment', Thrift.Type.STRING, 3);
      output.writeString(this.comment);
      output.writeFieldEnd();
    }
    if (this.policy !== null && this.policy !== undefined) {
      output.writeFieldBegin('policy', Thrift.Type.STRUCT, 4);
      this.policy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_updateSubStatusComment_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_updateSubStatusComment_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.startStageId = null;
    this.stages = null;
    this.contentItems = null;
    this.roles = null;
    this.patternVariables = null;
    this.accessPolicy = null;
    this.newRegNumber = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.startStageId !== undefined && args.startStageId !== null) {
        this.startStageId = args.startStageId;
      }
      if (args.stages !== undefined && args.stages !== null) {
        this.stages = Thrift.copyList(args.stages, [DocumentPatternStage]);
      }
      if (args.contentItems !== undefined && args.contentItems !== null) {
        this.contentItems = Thrift.copyList(args.contentItems, [ContentItem]);
      }
      if (args.roles !== undefined && args.roles !== null) {
        this.roles = Thrift.copyList(args.roles, [PatternProcessRole]);
      }
      if (args.patternVariables !== undefined && args.patternVariables !== null) {
        this.patternVariables = Thrift.copyList(args.patternVariables, [PatternVariable]);
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
      if (args.newRegNumber !== undefined && args.newRegNumber !== null) {
        this.newRegNumber = args.newRegNumber;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRING) {
          this.startStageId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 4:
        if (ftype == Thrift.Type.LIST) {
          this.stages = [];
          const _rtmp3591 = input.readListBegin();
          const _size590 = _rtmp3591.size || 0;
          for (let _i592 = 0; _i592 < _size590; ++_i592) {
            let elem593 = null;
            elem593 = new DocumentPatternStage();
            elem593.read(input);
            this.stages.push(elem593);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 5:
        if (ftype == Thrift.Type.LIST) {
          this.contentItems = [];
          const _rtmp3595 = input.readListBegin();
          const _size594 = _rtmp3595.size || 0;
          for (let _i596 = 0; _i596 < _size594; ++_i596) {
            let elem597 = null;
            elem597 = new ContentItem();
            elem597.read(input);
            this.contentItems.push(elem597);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 6:
        if (ftype == Thrift.Type.LIST) {
          this.roles = [];
          const _rtmp3599 = input.readListBegin();
          const _size598 = _rtmp3599.size || 0;
          for (let _i600 = 0; _i600 < _size598; ++_i600) {
            let elem601 = null;
            elem601 = new PatternProcessRole();
            elem601.read(input);
            this.roles.push(elem601);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 7:
        if (ftype == Thrift.Type.LIST) {
          this.patternVariables = [];
          const _rtmp3603 = input.readListBegin();
          const _size602 = _rtmp3603.size || 0;
          for (let _i604 = 0; _i604 < _size602; ++_i604) {
            let elem605 = null;
            elem605 = new PatternVariable();
            elem605.read(input);
            this.patternVariables.push(elem605);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 8:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 9:
        if (ftype == Thrift.Type.STRING) {
          this.newRegNumber = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.startStageId !== null && this.startStageId !== undefined) {
      output.writeFieldBegin('startStageId', Thrift.Type.STRING, 3);
      output.writeString(this.startStageId);
      output.writeFieldEnd();
    }
    if (this.stages !== null && this.stages !== undefined) {
      output.writeFieldBegin('stages', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.stages.length);
      for (let iter606 in this.stages) {
        if (this.stages.hasOwnProperty(iter606)) {
          iter606 = this.stages[iter606];
          iter606.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.contentItems !== null && this.contentItems !== undefined) {
      output.writeFieldBegin('contentItems', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.contentItems.length);
      for (let iter607 in this.contentItems) {
        if (this.contentItems.hasOwnProperty(iter607)) {
          iter607 = this.contentItems[iter607];
          iter607.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.roles !== null && this.roles !== undefined) {
      output.writeFieldBegin('roles', Thrift.Type.LIST, 6);
      output.writeListBegin(Thrift.Type.STRUCT, this.roles.length);
      for (let iter608 in this.roles) {
        if (this.roles.hasOwnProperty(iter608)) {
          iter608 = this.roles[iter608];
          iter608.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.patternVariables !== null && this.patternVariables !== undefined) {
      output.writeFieldBegin('patternVariables', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.patternVariables.length);
      for (let iter609 in this.patternVariables) {
        if (this.patternVariables.hasOwnProperty(iter609)) {
          iter609 = this.patternVariables[iter609];
          iter609.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 8);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    if (this.newRegNumber !== null && this.newRegNumber !== undefined) {
      output.writeFieldBegin('newRegNumber', Thrift.Type.STRING, 9);
      output.writeString(this.newRegNumber);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_changeDocumentType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.BOOL) {
          this.success = input.readBool().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_changeDocumentType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.BOOL, 0);
      output.writeBool(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_args = class {
  constructor(args) {
    this.token = null;
    this.docId = null;
    this.filter = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.docId !== undefined && args.docId !== null) {
        this.docId = args.docId;
      }
      if (args.filter !== undefined && args.filter !== null) {
        this.filter = new KazFilter(args.filter);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.docId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.filter = new KazFilter();
          this.filter.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.docId !== null && this.docId !== undefined) {
      output.writeFieldBegin('docId', Thrift.Type.STRING, 2);
      output.writeString(this.docId);
      output.writeFieldEnd();
    }
    if (this.filter !== null && this.filter !== undefined) {
      output.writeFieldBegin('filter', Thrift.Type.STRUCT, 3);
      this.filter.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocumentRelationModel_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new DocumentRelationModel(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new DocumentRelationModel();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocumentRelationModel_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_args = class {
  constructor(args) {
    this.token = null;
    this.prevAttId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.prevAttId !== undefined && args.prevAttId !== null) {
        this.prevAttId = args.prevAttId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.prevAttId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.prevAttId !== null && this.prevAttId !== undefined) {
      output.writeFieldBegin('prevAttId', Thrift.Type.STRING, 2);
      output.writeString(this.prevAttId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getNewConvertedAttachmentVersion_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Attachment(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Attachment();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getNewConvertedAttachmentVersion_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    this.accessPolicy = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
      if (args.accessPolicy !== undefined && args.accessPolicy !== null) {
        this.accessPolicy = new DocumentAccessPolicy(args.accessPolicy);
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 3:
        if (ftype == Thrift.Type.STRUCT) {
          this.accessPolicy = new DocumentAccessPolicy();
          this.accessPolicy.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    if (this.accessPolicy !== null && this.accessPolicy !== undefined) {
      output.writeFieldBegin('accessPolicy', Thrift.Type.STRUCT, 3);
      this.accessPolicy.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_exportAsXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = args.success;
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRING) {
          this.success = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_exportAsXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRING, 0);
      output.writeBinary(this.success);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_args = class {
  constructor(args) {
    this.token = null;
    this.xml = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.xml !== undefined && args.xml !== null) {
        this.xml = args.xml;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.xml = input.readBinary().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.xml !== null && this.xml !== undefined) {
      output.writeFieldBegin('xml', Thrift.Type.STRING, 2);
      output.writeBinary(this.xml);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_importFromXML_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = new Document(args.success);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.STRUCT) {
          this.success = new Document();
          this.success.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_importFromXML_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.STRUCT, 0);
      this.success.write(output);
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_args = class {
  constructor(args) {
    this.token = null;
    this.documentId = null;
    if (args) {
      if (args.token !== undefined && args.token !== null) {
        this.token = args.token;
      }
      if (args.documentId !== undefined && args.documentId !== null) {
        this.documentId = args.documentId;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
        if (ftype == Thrift.Type.STRING) {
          this.token = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRING) {
          this.documentId = input.readString().value;
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_args');
    if (this.token !== null && this.token !== undefined) {
      output.writeFieldBegin('token', Thrift.Type.STRING, 1);
      output.writeString(this.token);
      output.writeFieldEnd();
    }
    if (this.documentId !== null && this.documentId !== undefined) {
      output.writeFieldBegin('documentId', Thrift.Type.STRING, 2);
      output.writeString(this.documentId);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentService_getDocContentItemsForChangeType_result = class {
  constructor(args) {
    this.success = null;
    this.validError = null;
    this.error = null;
    if (args instanceof PreconditionException) {
        this.validError = args;
        return;
    }
    if (args instanceof ServerException) {
        this.error = args;
        return;
    }
    if (args) {
      if (args.success !== undefined && args.success !== null) {
        this.success = Thrift.copyList(args.success, [ContentItem]);
      }
      if (args.validError !== undefined && args.validError !== null) {
        this.validError = args.validError;
      }
      if (args.error !== undefined && args.error !== null) {
        this.error = args.error;
      }
    }
  }

  read (input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 0:
        if (ftype == Thrift.Type.LIST) {
          this.success = [];
          const _rtmp3611 = input.readListBegin();
          const _size610 = _rtmp3611.size || 0;
          for (let _i612 = 0; _i612 < _size610; ++_i612) {
            let elem613 = null;
            elem613 = new ContentItem();
            elem613.read(input);
            this.success.push(elem613);
          }
          input.readListEnd();
        } else {
          input.skip(ftype);
        }
        break;
        case 1:
        if (ftype == Thrift.Type.STRUCT) {
          this.validError = new PreconditionException();
          this.validError.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        case 2:
        if (ftype == Thrift.Type.STRUCT) {
          this.error = new ServerException();
          this.error.read(input);
        } else {
          input.skip(ftype);
        }
        break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write (output) {
    output.writeStructBegin('DocumentService_getDocContentItemsForChangeType_result');
    if (this.success !== null && this.success !== undefined) {
      output.writeFieldBegin('success', Thrift.Type.LIST, 0);
      output.writeListBegin(Thrift.Type.STRUCT, this.success.length);
      for (let iter614 in this.success) {
        if (this.success.hasOwnProperty(iter614)) {
          iter614 = this.success[iter614];
          iter614.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.validError !== null && this.validError !== undefined) {
      output.writeFieldBegin('validError', Thrift.Type.STRUCT, 1);
      this.validError.write(output);
      output.writeFieldEnd();
    }
    if (this.error !== null && this.error !== undefined) {
      output.writeFieldBegin('error', Thrift.Type.STRUCT, 2);
      this.error.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }

};
DocumentServiceClient = class {
  constructor(input, output) {
    this.input = input;
    this.output = (!output) ? input : output;
    this.seqid = 0;
  }

  calculatePermissions (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_calculatePermissions(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_calculatePermissions (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_calculatePermissions_args(params);
    try {
      this.output.writeMessageBegin('calculatePermissions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_calculatePermissions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_calculatePermissions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_calculatePermissions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'calculatePermissions failed: unknown result';
  }

  createOrUpdateDocument (token, document, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocument(token, document, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocument (token, document, accessPolicy, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocument_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocument failed: unknown result';
  }

  updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateDocument(token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateDocument (token, document, accessPolicy, addedResponsibles, removedResponsibles, addedSecurityClassificationIds, removedSecurityClassificationIds, callback) {
    const params = {
      token: token,
      document: document,
      accessPolicy: accessPolicy,
      addedResponsibles: addedResponsibles,
      removedResponsibles: removedResponsibles,
      addedSecurityClassificationIds: addedSecurityClassificationIds,
      removedSecurityClassificationIds: removedSecurityClassificationIds
    };
    const args = new DocumentService_updateDocument_args(params);
    try {
      this.output.writeMessageBegin('updateDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateDocument failed: unknown result';
  }

  createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocument(token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocument (token, document, users, holderLinks, securityClassificationsId, attachments, docRelations, callback) {
    const params = {
      token: token,
      document: document,
      users: users,
      holderLinks: holderLinks,
      securityClassificationsId: securityClassificationsId,
      attachments: attachments,
      docRelations: docRelations
    };
    const args = new DocumentService_createDocument_args(params);
    try {
      this.output.writeMessageBegin('createDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocument failed: unknown result';
  }

  createDocumentFromXML (token, xmlDoc) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createDocumentFromXML(token, xmlDoc, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createDocumentFromXML (token, xmlDoc, callback) {
    const params = {
      token: token,
      xmlDoc: xmlDoc
    };
    const args = new DocumentService_createDocumentFromXML_args(params);
    try {
      this.output.writeMessageBegin('createDocumentFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createDocumentFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createDocumentFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createDocumentFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createDocumentFromXML failed: unknown result';
  }

  getDocument (token, documentId, accessPolicy, decrypt, executorsPortion) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocument(token, documentId, accessPolicy, decrypt, executorsPortion, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocument (token, documentId, accessPolicy, decrypt, executorsPortion, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      decrypt: decrypt,
      executorsPortion: executorsPortion
    };
    const args = new DocumentService_getDocument_args(params);
    try {
      this.output.writeMessageBegin('getDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocument failed: unknown result';
  }

  getAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocuments failed: unknown result';
  }

  getCountAllDocuments (token, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountAllDocuments(token, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountAllDocuments (token, accessPolicy, filter, callback) {
    const params = {
      token: token,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getCountAllDocuments_args(params);
    try {
      this.output.writeMessageBegin('getCountAllDocuments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountAllDocuments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountAllDocuments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountAllDocuments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountAllDocuments failed: unknown result';
  }

  deleteDocument (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocument(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocument (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocument_args(params);
    try {
      this.output.writeMessageBegin('deleteDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocument failed: unknown result';
  }

  getAllPassedStages (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllPassedStages(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllPassedStages (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllPassedStages_args(params);
    try {
      this.output.writeMessageBegin('getAllPassedStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllPassedStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllPassedStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllPassedStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllPassedStages failed: unknown result';
  }

  getExecutionTree (token, documentId, accessPolicy, iteration, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getExecutionTree(token, documentId, accessPolicy, iteration, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getExecutionTree (token, documentId, accessPolicy, iteration, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      iteration: iteration,
      filter: filter
    };
    const args = new DocumentService_getExecutionTree_args(params);
    try {
      this.output.writeMessageBegin('getExecutionTree', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getExecutionTree();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getExecutionTree () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getExecutionTree_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getExecutionTree failed: unknown result';
  }

  getActiveStages (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getActiveStages(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getActiveStages (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getActiveStages_args(params);
    try {
      this.output.writeMessageBegin('getActiveStages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getActiveStages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getActiveStages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getActiveStages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getActiveStages failed: unknown result';
  }

  getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountPeoplesWhenRenderedDecision(token, documentId, stageId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountPeoplesWhenRenderedDecision (token, documentId, stageId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getCountPeoplesWhenRenderedDecision_args(params);
    try {
      this.output.writeMessageBegin('getCountPeoplesWhenRenderedDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountPeoplesWhenRenderedDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountPeoplesWhenRenderedDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountPeoplesWhenRenderedDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountPeoplesWhenRenderedDecision failed: unknown result';
  }

  setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecision(token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecision (token, documentId, decision, documentComment, force, signature, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      signature: signature,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecision failed: unknown result';
  }

  setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentDecisionUsingServerKeyStorage(token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentDecisionUsingServerKeyStorage (token, documentId, decision, documentComment, force, pKeyId, password, cardId, attachments, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      decision: decision,
      documentComment: documentComment,
      force: force,
      pKeyId: pKeyId,
      password: password,
      cardId: cardId,
      attachments: attachments,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentDecisionUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('setDocumentDecisionUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentDecisionUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentDecisionUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentDecisionUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentDecisionUsingServerKeyStorage failed: unknown result';
  }

  approveDocumentDecision (token, executionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_approveDocumentDecision(token, executionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_approveDocumentDecision (token, executionId, callback) {
    const params = {
      token: token,
      executionId: executionId
    };
    const args = new DocumentService_approveDocumentDecision_args(params);
    try {
      this.output.writeMessageBegin('approveDocumentDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_approveDocumentDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_approveDocumentDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_approveDocumentDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'approveDocumentDecision failed: unknown result';
  }

  shareDocument (token, documentId, accessPolicy, usersOrGroups) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_shareDocument(token, documentId, accessPolicy, usersOrGroups, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_shareDocument (token, documentId, accessPolicy, usersOrGroups, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      usersOrGroups: usersOrGroups
    };
    const args = new DocumentService_shareDocument_args(params);
    try {
      this.output.writeMessageBegin('shareDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_shareDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_shareDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_shareDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'shareDocument failed: unknown result';
  }

  revokeDocument (token, documentId, usersOrGroups, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDocument(token, documentId, usersOrGroups, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDocument (token, documentId, usersOrGroups, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      usersOrGroups: usersOrGroups,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeDocument_args(params);
    try {
      this.output.writeMessageBegin('revokeDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDocument failed: unknown result';
  }

  getAllDocumentSharings (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentSharings(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentSharings (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentSharings_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentSharings', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentSharings();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentSharings () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentSharings_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentSharings failed: unknown result';
  }

  getAllDocumentReassign (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentReassign(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentReassign (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentReassign failed: unknown result';
  }

  reassignDocument (token, documentId, documentReassign, cardId, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocument(token, documentId, documentReassign, cardId, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocument (token, documentId, documentReassign, cardId, signature, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      signature: signature
    };
    const args = new DocumentService_reassignDocument_args(params);
    try {
      this.output.writeMessageBegin('reassignDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocument failed: unknown result';
  }

  reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_reassignDocumentUsingServerKeyStorage(token, documentId, documentReassign, cardId, pKeyId, password, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_reassignDocumentUsingServerKeyStorage (token, documentId, documentReassign, cardId, pKeyId, password, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentReassign: documentReassign,
      cardId: cardId,
      pKeyId: pKeyId,
      password: password
    };
    const args = new DocumentService_reassignDocumentUsingServerKeyStorage_args(params);
    try {
      this.output.writeMessageBegin('reassignDocumentUsingServerKeyStorage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_reassignDocumentUsingServerKeyStorage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_reassignDocumentUsingServerKeyStorage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_reassignDocumentUsingServerKeyStorage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'reassignDocumentUsingServerKeyStorage failed: unknown result';
  }

  revokeChildCards (token, cardId, deleteCard, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeChildCards(token, cardId, deleteCard, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeChildCards (token, cardId, deleteCard, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      deleteCard: deleteCard,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_revokeChildCards_args(params);
    try {
      this.output.writeMessageBegin('revokeChildCards', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeChildCards();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeChildCards () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeChildCards_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeChildCards failed: unknown result';
  }

  createOrUpdateAutomaticDocumentReassign (token, documentReassign) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateAutomaticDocumentReassign(token, documentReassign, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateAutomaticDocumentReassign (token, documentReassign, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign
    };
    const args = new DocumentService_createOrUpdateAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateAutomaticDocumentReassign failed: unknown result';
  }

  deleteAutomaticDocumentReassign (token, documentReassignId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteAutomaticDocumentReassign(token, documentReassignId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteAutomaticDocumentReassign (token, documentReassignId, callback) {
    const params = {
      token: token,
      documentReassignId: documentReassignId
    };
    const args = new DocumentService_deleteAutomaticDocumentReassign_args(params);
    try {
      this.output.writeMessageBegin('deleteAutomaticDocumentReassign', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteAutomaticDocumentReassign();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteAutomaticDocumentReassign () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteAutomaticDocumentReassign_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteAutomaticDocumentReassign failed: unknown result';
  }

  changeReassignControl (token, documentExecutionId, userId, reassignType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeReassignControl(token, documentExecutionId, userId, reassignType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeReassignControl (token, documentExecutionId, userId, reassignType, callback) {
    const params = {
      token: token,
      documentExecutionId: documentExecutionId,
      userId: userId,
      reassignType: reassignType
    };
    const args = new DocumentService_changeReassignControl_args(params);
    try {
      this.output.writeMessageBegin('changeReassignControl', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeReassignControl();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeReassignControl () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeReassignControl_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeReassignControl failed: unknown result';
  }

  getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentExecutions(token, documentId, stageId, typeLink, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentExecutions (token, documentId, stageId, typeLink, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      stageId: stageId,
      typeLink: typeLink,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentExecutions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentExecutions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentExecutions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentExecutions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentExecutions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentExecutions failed: unknown result';
  }

  getDocumentExecution (token, docExecutionId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExecution(token, docExecutionId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExecution (token, docExecutionId, callback) {
    const params = {
      token: token,
      docExecutionId: docExecutionId
    };
    const args = new DocumentService_getDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExecution failed: unknown result';
  }

  changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeExecutorsForDocument(token, docId, toAdd, toClose, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeExecutorsForDocument (token, docId, toAdd, toClose, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      toAdd: toAdd,
      toClose: toClose,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeExecutorsForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeExecutorsForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeExecutorsForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeExecutorsForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeExecutorsForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeExecutorsForDocument failed: unknown result';
  }

  createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createAttachmentFrom(token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createAttachmentFrom (token, documentId, cardId, accessPolicy, attCreateInfoList, processingType, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy,
      attCreateInfoList: attCreateInfoList,
      processingType: processingType
    };
    const args = new DocumentService_createAttachmentFrom_args(params);
    try {
      this.output.writeMessageBegin('createAttachmentFrom', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createAttachmentFrom();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createAttachmentFrom () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createAttachmentFrom_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createAttachmentFrom failed: unknown result';
  }

  createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createLoadableAttachment(token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createLoadableAttachment (token, documentId, fileName, totalSize, countPortions, cardId, attachmmentId, forDraft, accessPolicy, editMode, meetingId, extStatus, callback) {
    const params = {
      token: token,
      documentId: documentId,
      fileName: fileName,
      totalSize: totalSize,
      countPortions: countPortions,
      cardId: cardId,
      attachmmentId: attachmmentId,
      forDraft: forDraft,
      accessPolicy: accessPolicy,
      editMode: editMode,
      meetingId: meetingId,
      extStatus: extStatus
    };
    const args = new DocumentService_createLoadableAttachment_args(params);
    try {
      this.output.writeMessageBegin('createLoadableAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createLoadableAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createLoadableAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createLoadableAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createLoadableAttachment failed: unknown result';
  }

  uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_uploadDocumentAttachmentPortions(token, attachmentId, numberPortion, fileContentBytes, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_uploadDocumentAttachmentPortions (token, attachmentId, numberPortion, fileContentBytes, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      numberPortion: numberPortion,
      fileContentBytes: fileContentBytes
    };
    const args = new DocumentService_uploadDocumentAttachmentPortions_args(params);
    try {
      this.output.writeMessageBegin('uploadDocumentAttachmentPortions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_uploadDocumentAttachmentPortions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_uploadDocumentAttachmentPortions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_uploadDocumentAttachmentPortions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'uploadDocumentAttachmentPortions failed: unknown result';
  }

  downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_downloadDocumentAttachment(token, attachmentId, attachmentType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_downloadDocumentAttachment (token, attachmentId, attachmentType, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      attachmentType: attachmentType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_downloadDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('downloadDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_downloadDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_downloadDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_downloadDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'downloadDocumentAttachment failed: unknown result';
  }

  rotatePdfPages (token, attachmentId, pages, angle, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_rotatePdfPages(token, attachmentId, pages, angle, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_rotatePdfPages (token, attachmentId, pages, angle, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      pages: pages,
      angle: angle,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_rotatePdfPages_args(params);
    try {
      this.output.writeMessageBegin('rotatePdfPages', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_rotatePdfPages();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_rotatePdfPages () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_rotatePdfPages_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'rotatePdfPages failed: unknown result';
  }

  addAttachmentsToDocument (token, documentId, attachments, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAttachmentsToDocument(token, documentId, attachments, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAttachmentsToDocument (token, documentId, attachments, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      attachments: attachments,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAttachmentsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addAttachmentsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAttachmentsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAttachmentsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAttachmentsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAttachmentsToDocument failed: unknown result';
  }

  removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeDocumentAttachment(token, attachmentId, removeOldVersions, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeDocumentAttachment (token, attachmentId, removeOldVersions, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      removeOldVersions: removeOldVersions,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeDocumentAttachment_args(params);
    try {
      this.output.writeMessageBegin('removeDocumentAttachment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeDocumentAttachment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeDocumentAttachment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeDocumentAttachment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeDocumentAttachment failed: unknown result';
  }

  markAsWaitForPublish (token, attachmentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markAsWaitForPublish(token, attachmentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markAsWaitForPublish (token, attachmentId, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId
    };
    const args = new DocumentService_markAsWaitForPublish_args(params);
    try {
      this.output.writeMessageBegin('markAsWaitForPublish', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markAsWaitForPublish();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markAsWaitForPublish () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markAsWaitForPublish_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markAsWaitForPublish failed: unknown result';
  }

  changeAttachmentEditMode (token, attachmentId, editMode) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentEditMode(token, attachmentId, editMode, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentEditMode (token, attachmentId, editMode, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      editMode: editMode
    };
    const args = new DocumentService_changeAttachmentEditMode_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentEditMode', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentEditMode();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentEditMode () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentEditMode_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentEditMode failed: unknown result';
  }

  getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachments(token, documentId, latestOnly, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachments (token, documentId, latestOnly, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      latestOnly: latestOnly,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachments_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachments failed: unknown result';
  }

  getDocumentAttachmentById (token, attachmentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentAttachmentById(token, attachmentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentAttachmentById (token, attachmentId, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentAttachmentById_args(params);
    try {
      this.output.writeMessageBegin('getDocumentAttachmentById', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentAttachmentById();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentAttachmentById () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentAttachmentById_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentAttachmentById failed: unknown result';
  }

  getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentAttachmentVersions(token, attachmentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentAttachmentVersions (token, attachmentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      attachmentId: attachmentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentAttachmentVersions_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentAttachmentVersions', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentAttachmentVersions();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentAttachmentVersions () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentAttachmentVersions_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentAttachmentVersions failed: unknown result';
  }

  changeAttachmentsVisibility (token, toHideList, toShowList) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentsVisibility(token, toHideList, toShowList, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentsVisibility (token, toHideList, toShowList, callback) {
    const params = {
      token: token,
      toHideList: toHideList,
      toShowList: toShowList
    };
    const args = new DocumentService_changeAttachmentsVisibility_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentsVisibility', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentsVisibility();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentsVisibility () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentsVisibility_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentsVisibility failed: unknown result';
  }

  createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentComment(token, documentComment, addToComment, changeType, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentComment (token, documentComment, addToComment, changeType, accessPolicy, callback) {
    const params = {
      token: token,
      documentComment: documentComment,
      addToComment: addToComment,
      changeType: changeType,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentComment failed: unknown result';
  }

  getAllDocumentComments (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentComments(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentComments (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentComments_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentComments', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentComments();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentComments () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentComments_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentComments failed: unknown result';
  }

  deleteDocumentComment (token, documentCommentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentComment(token, documentCommentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentComment (token, documentCommentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentCommentId: documentCommentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentComment_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentComment failed: unknown result';
  }

  createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentHolderLink(token, documentId, holderLinks, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentHolderLink (token, documentId, holderLinks, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      holderLinks: holderLinks,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentHolderLink_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentHolderLink', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentHolderLink();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentHolderLink () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentHolderLink_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentHolderLink failed: unknown result';
  }

  createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createOrUpdateDocumentContentTab(token, documentId, documentContentTab, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createOrUpdateDocumentContentTab (token, documentId, documentContentTab, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentContentTab: documentContentTab,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_createOrUpdateDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('createOrUpdateDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createOrUpdateDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createOrUpdateDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createOrUpdateDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createOrUpdateDocumentContentTab failed: unknown result';
  }

  getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentContentTabsByFilter(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentContentTabsByFilter (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getDocumentContentTabsByFilter_args(params);
    try {
      this.output.writeMessageBegin('getDocumentContentTabsByFilter', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentContentTabsByFilter();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentContentTabsByFilter () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentContentTabsByFilter_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentContentTabsByFilter failed: unknown result';
  }

  deleteDocumentContentTab (token, documentContentTabId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_deleteDocumentContentTab(token, documentContentTabId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_deleteDocumentContentTab (token, documentContentTabId, accessPolicy, callback) {
    const params = {
      token: token,
      documentContentTabId: documentContentTabId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_deleteDocumentContentTab_args(params);
    try {
      this.output.writeMessageBegin('deleteDocumentContentTab', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_deleteDocumentContentTab();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_deleteDocumentContentTab () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_deleteDocumentContentTab_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'deleteDocumentContentTab failed: unknown result';
  }

  documentToArchive (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_documentToArchive(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_documentToArchive (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_documentToArchive_args(params);
    try {
      this.output.writeMessageBegin('documentToArchive', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_documentToArchive();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_documentToArchive () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_documentToArchive_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'documentToArchive failed: unknown result';
  }

  getAllResponsibleForDocument (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllResponsibleForDocument(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllResponsibleForDocument (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getAllResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('getAllResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllResponsibleForDocument failed: unknown result';
  }

  addResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('addResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addResponsibleForDocument failed: unknown result';
  }

  removeResponsibleForDocument (token, documentId, users, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeResponsibleForDocument(token, documentId, users, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeResponsibleForDocument (token, documentId, users, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      users: users,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_removeResponsibleForDocument_args(params);
    try {
      this.output.writeMessageBegin('removeResponsibleForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeResponsibleForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeResponsibleForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeResponsibleForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeResponsibleForDocument failed: unknown result';
  }

  getDocHistoryPage (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocHistoryPage(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocHistoryPage (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocHistoryPage_args(params);
    try {
      this.output.writeMessageBegin('getDocHistoryPage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocHistoryPage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocHistoryPage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocHistoryPage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocHistoryPage failed: unknown result';
  }

  getAllNews (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllNews(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllNews (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getAllNews_args(params);
    try {
      this.output.writeMessageBegin('getAllNews', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllNews();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllNews () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllNews_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllNews failed: unknown result';
  }

  getTasksByDate (token, date) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTasksByDate(token, date, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTasksByDate (token, date, callback) {
    const params = {
      token: token,
      date: date
    };
    const args = new DocumentService_getTasksByDate_args(params);
    try {
      this.output.writeMessageBegin('getTasksByDate', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTasksByDate();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTasksByDate () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTasksByDate_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTasksByDate failed: unknown result';
  }

  generateDocumentNumber (token, documentId, docNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_generateDocumentNumber(token, documentId, docNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_generateDocumentNumber (token, documentId, docNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      docNumber: docNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_generateDocumentNumber_args(params);
    try {
      this.output.writeMessageBegin('generateDocumentNumber', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_generateDocumentNumber();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_generateDocumentNumber () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_generateDocumentNumber_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'generateDocumentNumber failed: unknown result';
  }

  setDocumentViewed (token, documentId, viewed, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setDocumentViewed(token, documentId, viewed, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setDocumentViewed (token, documentId, viewed, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      viewed: viewed,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_setDocumentViewed_args(params);
    try {
      this.output.writeMessageBegin('setDocumentViewed', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setDocumentViewed();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setDocumentViewed () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setDocumentViewed_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setDocumentViewed failed: unknown result';
  }

  getAllDocumentRelations (token, documentId, filter, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllDocumentRelations(token, documentId, filter, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllDocumentRelations (token, documentId, filter, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      filter: filter,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_getAllDocumentRelations_args(params);
    try {
      this.output.writeMessageBegin('getAllDocumentRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllDocumentRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllDocumentRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllDocumentRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllDocumentRelations failed: unknown result';
  }

  changeRelations (token, toCreate, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRelations(token, toCreate, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRelations (token, toCreate, toRemove, callback) {
    const params = {
      token: token,
      toCreate: toCreate,
      toRemove: toRemove
    };
    const args = new DocumentService_changeRelations_args(params);
    try {
      this.output.writeMessageBegin('changeRelations', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRelations();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRelations () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRelations_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRelations failed: unknown result';
  }

  changeSubStatus (token, documentId, subStatus, comment, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeSubStatus(token, documentId, subStatus, comment, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeSubStatus (token, documentId, subStatus, comment, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      subStatus: subStatus,
      comment: comment,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeSubStatus_args(params);
    try {
      this.output.writeMessageBegin('changeSubStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeSubStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeSubStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeSubStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeSubStatus failed: unknown result';
  }

  increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_increaseDeadlineForDocumentOrDocumentExecution(token, documentId, documentExecution, deadlineTime, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_increaseDeadlineForDocumentOrDocumentExecution (token, documentId, documentExecution, deadlineTime, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      documentExecution: documentExecution,
      deadlineTime: deadlineTime,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_args(params);
    try {
      this.output.writeMessageBegin('increaseDeadlineForDocumentOrDocumentExecution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_increaseDeadlineForDocumentOrDocumentExecution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_increaseDeadlineForDocumentOrDocumentExecution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_increaseDeadlineForDocumentOrDocumentExecution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'increaseDeadlineForDocumentOrDocumentExecution failed: unknown result';
  }

  addAdditionalConfirmers (token, cardId, users, deadlineDate, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addAdditionalConfirmers(token, cardId, users, deadlineDate, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addAdditionalConfirmers (token, cardId, users, deadlineDate, accessPolicy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      users: users,
      deadlineDate: deadlineDate,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addAdditionalConfirmers_args(params);
    try {
      this.output.writeMessageBegin('addAdditionalConfirmers', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addAdditionalConfirmers();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addAdditionalConfirmers () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addAdditionalConfirmers_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addAdditionalConfirmers failed: unknown result';
  }

  setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_setAdditionalDecision(token, userDecision, cardId, comment, returnToParentStage, signature, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_setAdditionalDecision (token, userDecision, cardId, comment, returnToParentStage, signature, callback) {
    const params = {
      token: token,
      userDecision: userDecision,
      cardId: cardId,
      comment: comment,
      returnToParentStage: returnToParentStage,
      signature: signature
    };
    const args = new DocumentService_setAdditionalDecision_args(params);
    try {
      this.output.writeMessageBegin('setAdditionalDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_setAdditionalDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_setAdditionalDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_setAdditionalDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'setAdditionalDecision failed: unknown result';
  }

  revokeDecision (token, documentReassign, cardId, comment) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_revokeDecision(token, documentReassign, cardId, comment, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_revokeDecision (token, documentReassign, cardId, comment, callback) {
    const params = {
      token: token,
      documentReassign: documentReassign,
      cardId: cardId,
      comment: comment
    };
    const args = new DocumentService_revokeDecision_args(params);
    try {
      this.output.writeMessageBegin('revokeDecision', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_revokeDecision();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_revokeDecision () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_revokeDecision_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'revokeDecision failed: unknown result';
  }

  markDecisionAsRemoved (token, documentId, cardId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_markDecisionAsRemoved(token, documentId, cardId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_markDecisionAsRemoved (token, documentId, cardId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      cardId: cardId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_markDecisionAsRemoved_args(params);
    try {
      this.output.writeMessageBegin('markDecisionAsRemoved', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_markDecisionAsRemoved();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_markDecisionAsRemoved () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_markDecisionAsRemoved_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'markDecisionAsRemoved failed: unknown result';
  }

  getAllOpenDocumentExecutionsStatistic (token, userId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getAllOpenDocumentExecutionsStatistic(token, userId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getAllOpenDocumentExecutionsStatistic (token, userId, callback) {
    const params = {
      token: token,
      userId: userId
    };
    const args = new DocumentService_getAllOpenDocumentExecutionsStatistic_args(params);
    try {
      this.output.writeMessageBegin('getAllOpenDocumentExecutionsStatistic', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getAllOpenDocumentExecutionsStatistic();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getAllOpenDocumentExecutionsStatistic () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getAllOpenDocumentExecutionsStatistic_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getAllOpenDocumentExecutionsStatistic failed: unknown result';
  }

  changeControlForDocument (token, documentId, control, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeControlForDocument(token, documentId, control, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeControlForDocument (token, documentId, control, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      control: control,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeControlForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeControlForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeControlForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeControlForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeControlForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeControlForDocument failed: unknown result';
  }

  addTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_addTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('addTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addTagsToDocument failed: unknown result';
  }

  removeTagsToDocument (token, docId, tags) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_removeTagsToDocument(token, docId, tags, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_removeTagsToDocument (token, docId, tags, callback) {
    const params = {
      token: token,
      docId: docId,
      tags: tags
    };
    const args = new DocumentService_removeTagsToDocument_args(params);
    try {
      this.output.writeMessageBegin('removeTagsToDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_removeTagsToDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_removeTagsToDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_removeTagsToDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'removeTagsToDocument failed: unknown result';
  }

  addExecutorsToStage (token, docId, documentReassign, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_addExecutorsToStage(token, docId, documentReassign, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_addExecutorsToStage (token, docId, documentReassign, accessPolicy, callback) {
    const params = {
      token: token,
      docId: docId,
      documentReassign: documentReassign,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_addExecutorsToStage_args(params);
    try {
      this.output.writeMessageBegin('addExecutorsToStage', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_addExecutorsToStage();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_addExecutorsToStage () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_addExecutorsToStage_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'addExecutorsToStage failed: unknown result';
  }

  getCountDocsByFilterNoPermission (token, patternGroupId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getCountDocsByFilterNoPermission(token, patternGroupId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getCountDocsByFilterNoPermission (token, patternGroupId, filter, callback) {
    const params = {
      token: token,
      patternGroupId: patternGroupId,
      filter: filter
    };
    const args = new DocumentService_getCountDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getCountDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getCountDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getCountDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getCountDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getCountDocsByFilterNoPermission failed: unknown result';
  }

  getTinyDocsByFilterNoPermission (token, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getTinyDocsByFilterNoPermission(token, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getTinyDocsByFilterNoPermission (token, filter, callback) {
    const params = {
      token: token,
      filter: filter
    };
    const args = new DocumentService_getTinyDocsByFilterNoPermission_args(params);
    try {
      this.output.writeMessageBegin('getTinyDocsByFilterNoPermission', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getTinyDocsByFilterNoPermission();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getTinyDocsByFilterNoPermission () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getTinyDocsByFilterNoPermission_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getTinyDocsByFilterNoPermission failed: unknown result';
  }

  changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeRegistrationInfoForDocument(token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeRegistrationInfoForDocument (token, documentId, newRegistrationDate, newRegistrationNumber, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      newRegistrationDate: newRegistrationDate,
      newRegistrationNumber: newRegistrationNumber,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_changeRegistrationInfoForDocument_args(params);
    try {
      this.output.writeMessageBegin('changeRegistrationInfoForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeRegistrationInfoForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeRegistrationInfoForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeRegistrationInfoForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeRegistrationInfoForDocument failed: unknown result';
  }

  createChatForDocument (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_createChatForDocument(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_createChatForDocument (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_createChatForDocument_args(params);
    try {
      this.output.writeMessageBegin('createChatForDocument', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_createChatForDocument();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_createChatForDocument () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_createChatForDocument_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'createChatForDocument failed: unknown result';
  }

  getDocumentExtShareList (token, documentId, accessPolicy, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentExtShareList(token, documentId, accessPolicy, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentExtShareList (token, documentId, accessPolicy, filter, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      filter: filter
    };
    const args = new DocumentService_getDocumentExtShareList_args(params);
    try {
      this.output.writeMessageBegin('getDocumentExtShareList', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentExtShareList();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentExtShareList () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentExtShareList_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentExtShareList failed: unknown result';
  }

  changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentExtShare(token, documentId, accessPolicy, toAdd, toRemove, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentExtShare (token, documentId, accessPolicy, toAdd, toRemove, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy,
      toAdd: toAdd,
      toRemove: toRemove
    };
    const args = new DocumentService_changeDocumentExtShare_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentExtShare', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentExtShare();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentExtShare () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentExtShare_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentExtShare failed: unknown result';
  }

  changeAttachmentExtStatus (token, statusMap) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeAttachmentExtStatus(token, statusMap, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeAttachmentExtStatus (token, statusMap, callback) {
    const params = {
      token: token,
      statusMap: statusMap
    };
    const args = new DocumentService_changeAttachmentExtStatus_args(params);
    try {
      this.output.writeMessageBegin('changeAttachmentExtStatus', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeAttachmentExtStatus();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeAttachmentExtStatus () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeAttachmentExtStatus_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeAttachmentExtStatus failed: unknown result';
  }

  remindDocumentExecutor (token, cardId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_remindDocumentExecutor(token, cardId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_remindDocumentExecutor (token, cardId, comment, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_remindDocumentExecutor_args(params);
    try {
      this.output.writeMessageBegin('remindDocumentExecutor', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_remindDocumentExecutor();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_remindDocumentExecutor () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_remindDocumentExecutor_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'remindDocumentExecutor failed: unknown result';
  }

  updateReassignResolution (token, cardId, resolution, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateReassignResolution(token, cardId, resolution, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateReassignResolution (token, cardId, resolution, policy, callback) {
    const params = {
      token: token,
      cardId: cardId,
      resolution: resolution,
      policy: policy
    };
    const args = new DocumentService_updateReassignResolution_args(params);
    try {
      this.output.writeMessageBegin('updateReassignResolution', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateReassignResolution();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateReassignResolution () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateReassignResolution_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateReassignResolution failed: unknown result';
  }

  updateSubStatusComment (token, docCommentId, comment, policy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_updateSubStatusComment(token, docCommentId, comment, policy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_updateSubStatusComment (token, docCommentId, comment, policy, callback) {
    const params = {
      token: token,
      docCommentId: docCommentId,
      comment: comment,
      policy: policy
    };
    const args = new DocumentService_updateSubStatusComment_args(params);
    try {
      this.output.writeMessageBegin('updateSubStatusComment', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_updateSubStatusComment();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_updateSubStatusComment () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_updateSubStatusComment_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'updateSubStatusComment failed: unknown result';
  }

  changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_changeDocumentType(token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_changeDocumentType (token, docId, startStageId, stages, contentItems, roles, patternVariables, accessPolicy, newRegNumber, callback) {
    const params = {
      token: token,
      docId: docId,
      startStageId: startStageId,
      stages: stages,
      contentItems: contentItems,
      roles: roles,
      patternVariables: patternVariables,
      accessPolicy: accessPolicy,
      newRegNumber: newRegNumber
    };
    const args = new DocumentService_changeDocumentType_args(params);
    try {
      this.output.writeMessageBegin('changeDocumentType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_changeDocumentType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_changeDocumentType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_changeDocumentType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'changeDocumentType failed: unknown result';
  }

  getDocumentRelationModel (token, docId, filter) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocumentRelationModel(token, docId, filter, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocumentRelationModel (token, docId, filter, callback) {
    const params = {
      token: token,
      docId: docId,
      filter: filter
    };
    const args = new DocumentService_getDocumentRelationModel_args(params);
    try {
      this.output.writeMessageBegin('getDocumentRelationModel', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocumentRelationModel();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocumentRelationModel () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocumentRelationModel_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocumentRelationModel failed: unknown result';
  }

  getNewConvertedAttachmentVersion (token, prevAttId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getNewConvertedAttachmentVersion(token, prevAttId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getNewConvertedAttachmentVersion (token, prevAttId, callback) {
    const params = {
      token: token,
      prevAttId: prevAttId
    };
    const args = new DocumentService_getNewConvertedAttachmentVersion_args(params);
    try {
      this.output.writeMessageBegin('getNewConvertedAttachmentVersion', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getNewConvertedAttachmentVersion();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getNewConvertedAttachmentVersion () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getNewConvertedAttachmentVersion_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getNewConvertedAttachmentVersion failed: unknown result';
  }

  exportAsXML (token, documentId, accessPolicy) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_exportAsXML(token, documentId, accessPolicy, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_exportAsXML (token, documentId, accessPolicy, callback) {
    const params = {
      token: token,
      documentId: documentId,
      accessPolicy: accessPolicy
    };
    const args = new DocumentService_exportAsXML_args(params);
    try {
      this.output.writeMessageBegin('exportAsXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_exportAsXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_exportAsXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_exportAsXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'exportAsXML failed: unknown result';
  }

  importFromXML (token, xml) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_importFromXML(token, xml, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_importFromXML (token, xml, callback) {
    const params = {
      token: token,
      xml: xml
    };
    const args = new DocumentService_importFromXML_args(params);
    try {
      this.output.writeMessageBegin('importFromXML', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_importFromXML();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_importFromXML () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_importFromXML_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'importFromXML failed: unknown result';
  }

  getDocContentItemsForChangeType (token, documentId) {
    const self = this;
    return new Promise((resolve, reject) => {
      self.send_getDocContentItemsForChangeType(token, documentId, (error, result) => {
        return error ? reject(error) : resolve(result);
      });
    });
  }

  send_getDocContentItemsForChangeType (token, documentId, callback) {
    const params = {
      token: token,
      documentId: documentId
    };
    const args = new DocumentService_getDocContentItemsForChangeType_args(params);
    try {
      this.output.writeMessageBegin('getDocContentItemsForChangeType', Thrift.MessageType.CALL, this.seqid);
      args.write(this.output);
      this.output.writeMessageEnd();
      const self = this;
      this.output.getTransport().flush(true, () => {
        let error = null, result = null;
        try {
          result = self.recv_getDocContentItemsForChangeType();
        } catch (e) {
          error = e;
        }
        callback(error, result);
      });
    }
    catch (e) {
      if (typeof this.output.getTransport().reset === 'function') {
        this.output.getTransport().reset();
      }
      throw e;
    }
  }

  recv_getDocContentItemsForChangeType () {
    const ret = this.input.readMessageBegin();
    const mtype = ret.mtype;
    if (mtype == Thrift.MessageType.EXCEPTION) {
      const x = new Thrift.TApplicationException();
      x.read(this.input);
      this.input.readMessageEnd();
      throw x;
    }
    const result = new DocumentService_getDocContentItemsForChangeType_result();
    result.read(this.input);
    this.input.readMessageEnd();

    if (null !== result.validError) {
      throw result.validError;
    }
    if (null !== result.error) {
      throw result.error;
    }
    if (null !== result.success) {
      return result.success;
    }
    throw 'getDocContentItemsForChangeType failed: unknown result';
  }
};
